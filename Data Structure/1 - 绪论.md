## 第 1 章 绪论

### 1.1 数据结构基础概念

#### 数据
数据是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。

#### 数据元素
数据元素是组成数据的基本单位，是数据集合的个体。

#### 数据对象
数据对象是性质相同的数据元素的集合，是数据的一个子集。

> ***数据概念归纳如下：***
> - **数据特点**：
>   - 可**被计算机接收**（与计算机的关联性）
>   - 可**被加工**（能被处理）
> - **数据构成**：
>   - **数据元素**——组成数据**基本单位**（是数据集合的个体）
>   - **数据对象**——**性质相同**的数据元素的**集合**（是数据集合的子集）

#### 数据结构
数据结构是指相互之间存在一种或多种特定关系的数据元素集合，是**带有结构**和**数据元素**的集合。

#### 数据类型
数据类型是一组性质相同的值集合以及定义在这个值几何上的一组操作的总称。

> ***数据类型分类：***
> - **原子类型**
>   - 不可再分的
> - **结构类型**
>   - 可以分解的
>   - 成分可以是原子的，也可以是结构的

#### 抽象数据类型
*抽象的本质是抽取反映问题的本质点，而忽略非本质的细节。*

1.  **数据的抽象**
    高级语言提供整型、实型、字符、记录、文件、指针等多种数据类型，可以利用这些类型构造出像栈、队列、树、图等复杂的抽象数据类型。
    
2.  **抽象数据类型（ADT）**
    抽象数据类型（Abstract Data Type, ADT）定义了一个**数据对象**、**数据对象中各元素间的结构关系**以及**一组处理数据的操作**。
        
    抽象数据类型最重要的特点是**数据抽象**与**信息屏蔽**。

    ADT包括**数据对象**、**数据元素**间的**结构关系**、**操作**三个部分。
    
    <br>

    > ***ADT定义格式有多种，下为一种方式：***
    > ```
    > ADT <ADT名>
    > {
    >     数据对象：<数据对象的定义>
    >     结构关系：<结构关系的定义>
    >     基本操作：<基本操作的定义>
    > } ADT <ADT名>
    > ```


---


### 1.2 数据结构的内容

#### 逻辑结构
数据的逻辑结构是指数据元素之间**逻辑关系描述**。

形式定义为：数据结构是一个二元组
$$ Data\_Structure = (D, R) $$

其中，$ D $ 是数据元素的有限集，$ R $ 是 $ D $ 上关系的有限集。

> **例如：**
> $$ \\
> DS_2 = (D_2, R_2) \\
> D_2 = \{ a, b, c, d, e, f \} \\
> R_2 = \{ T \} \\
> T = \{ <a, b>, <a, c>, <a, d>, <c, e>, <c, f> \} \\
> $$

根据数据元素之间关系的不同特性，通常有以下四类基本结构：
1. **集合结构**：结构中的数据元素之间除了**同属于一个集合**的关系外，**无任何其他关系**。
2. **线性结构**：结构中的数据元素之间存在着**一对一的线性关系**。
3. **树状结构**：结构中的数据元素之间存在着**一对多的层次关系**。
4. **图状结构或网状结构**：结构中的数据元素之间存在着**多对多的任意关系**。

> ***数据的四类基本逻辑结构可概括如下：***
> - **线性结构**——线性表、栈、队、字符串、数组、广义表
> - **非线性结构**——树、图

#### 存储结构
存储结构（又称物理结构）是**逻辑结构在计算机中的存储映像**。
> 包括**数据元素映像**和**关系映像**。
> 是**逻辑结构**在计算机中的**实现**。
> 包括**数据元素的表示**和**关系的表示**。

**形式化描述**：对于一种数据结构 $ (D, R) $，要将 $ D $ 存入计算机中，建立一种从 $ D $ 的数据元素到存储空间 $ M $ 单元的映像 $ S $，即 $ D → M $，也就是说对于每一个 $ d $，$ d ∈ D $，都有唯一的 $ z ∈ M $ 使 $ S(D) = Z $，同时这个映像必须明显或隐含地体现关系 $ R $。

> ***逻辑结构与存储结构的关系***
> - 存储结构是**逻辑关系的映像**与**元素本身的映像**。
> - **逻辑结构是数据结构的抽象，存储结构是数据结构的实现**，两者综合起来建立了**数据元素之间的结构关系**。

> ***数据元素之间的关系在计算机中有两种不同的表示方法：***
> - **顺序映像**（顺序存储结构）
> - **非顺序映像**（非顺序存储结构）

#### 运算集合
讨论数据结构的目的是为了在计算机中实现操作，因此在结构上的运算集合是很重要的部分。数据结构就是研究一类数据的表示及其相关的运算操作。

如在某工资表中，可以采用**线性表的逻辑结构**；怎么存放就是具体**存储结构**的问题了；对工资表作出的增、删、改等操作就是数据的**操作集合**。

<br>

**综上所述，按某种逻辑关系组织起来的一批数据，按一定的映像方式把它们存放在计算机的存储器中，并在这些数据上定义一个运算的集合，这些是数据结构课程的基本内容。**


---


### 1.3 算法

#### 算法定义
算法（Algorithm）是规则的有限集合，是为解决特定问题而规定的一系列操作。

#### 算法的特性
1. **有限性**：有限步骤之内正常结束，不能形成无穷循环。
2. **确定性**：算法中的每一个步骤必须有确定含义，无二义性。
3. **可行性**：原则上能精确进行，操作可通过已实现的基本运算执行有次而完成。
4. **输入**：有多个或 0 个输入。
5. **输出**：至少有一个或多个输出。

> 在算法的五大特性中，最基本的是**有限性**、**确定性**和**可行性**这三个特性。

#### 算法设计的要求
1. **算法的正确性**
    - 算法对于几组输入数据能够得出满足要求的结果。
    - 算法对于精心选择的典型、苛刻而带有刁难性的输入数据能够得出满足要求的结果。
    - 算法对于一切合法的输入数据都能产生满足要求的结果。

    > 达到第三层含义下的正确是极为困难的，一般情况下，至少应以**第二层含义的正确**作为衡量一个算法是否正确的标准。

2. **可读性**

3. **健壮性（鲁棒性）**

4. **高效率和低存储量**


---


### 1.4 算法描述

#### 算法、语言、程序的关系
1. **算法**：描述数据对象之间的关系（包括数据逻辑关系、存储关系描述）
2. **描述算法的工具**：算法可用自然语言、框图或高级程序设计语言进行描述。
3. **程序是算法在计算机中的实现**（与所用计算机及所用语言有关）。

#### 设计实现算法过程的步骤
1. 找出与求解有关的数据元素之间的关系（**建立结构关系**）。
2. **确定**在某一数据对象上所施加的**运算**。
3. 考虑数据元素的**存储表示**。
4. 选择**描述算法的语言**。
5. 设计**实现求解的算法**，并**用程序语言加以描述**。

#### 描述算法的语言选择
以下使用 C 语言，个别之处采用简化示意。


---


### 1.5 算法性能评价

#### 算法耗费的时间
一个算法的执行时间是指算法中所有语句执行时间的总和。每条语句的执行时间等于该条语句的执行次数乘以执行一次所需的实际时间。

#### 语句频度
语句频度是指**该语句在一个算法中重复执行的次数。**
一个算法的时间耗费就是该算法中所有语句频度之和。

> ***示例：求两个 n 阶方阵的乘积 `C = A × B`***
> ```c
> #define n 100
> void MatrixMulti(int a[n][n], int b[n][n], int c[n][n])
> {
>     for (int i = 0; i < n; i++) // n + 1
>         for (int j = 0; j < n; j++) // n * (n + 1)
>         {
>             c[i][j] = 0; // n * n
>             for (int k = 0; k < n; k++) // n * n * (n + 1)
>                 c[i][j] = c[i][j] + a[i][k] * b[k][j]; // n * n * n
>         }
> }
> ```
> 在每一个语句后面都标示出了其语句频度。
> 该算法中**所有语句的频度之和**（即**算法的时间耗费**）为：
> **$$ f(n) = 2n^3 + 3n^2 + 2n + 1 $$**

#### 算法的时间复杂度
为便于比较同一问题的不同算法，通常以算法中**基本操作重复执行的频度**作为度量标准。

算法的时间复杂度 $ T(n) $ 是该算法的时间度量，记作 **$$ T(n) = O(f(n)) $$**

它表示随问题规模 $ n $ 的增大，算法的执行时间的增长率和 $ F(n) $ 的增长率相同，称作算法的渐近时间复杂度，简称**时间复杂度**。

在上面的算法 `MatrixMulti` 中，由于 $ f(n) $ 和 $ n^3 $ 同阶，或者说数量级相同，因此 $ O(n^3) $ 是算法 `MatrixMulti` 的渐近时间复杂度。

#### 渐近时间复杂度
主要用算法**时间复杂度的数量级**（即算法的**渐近时间复杂度**）来评价一个算法的**时间性能**。

#### 常用算法时间复杂度
数据结构中常用的时间复杂度频率计数有以下 7 种：
- 常数型：$ O(1) $
- 线性型：$ O(n) $
- 平方型：$ O(n^2) $
- 立方型：$ O(n^3) $
- 指数型：$ O(2^n) $
- 对数型：$ O(log_2n) $
- 二维型：$ O(nlog_2n) $

> 一般来说，前三种可实现，后三种虽理论上可实现，但实际上只有当 $ n $ 限制在很小的范围内时才有意义。

> 一般情况下，**随 $ n $ 的增大，$ T(n) $ 的增长较慢的算法为最优算法**，因此应该选择使用多项式阶 $ O(n^2) $ 的算法，而避免使用指数阶的算法。

#### 最坏时间复杂度和平均时间复杂度
算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。
> ***示例：在数值 `A[0..n-1]` 中查找给定值 `k` 的算法***
> ```c
> i = n - 1;
> while (i >= 0 && (A[i] != k ))
>     i--;  // 语句 (3)
> return i;
> ```
> 此算法中，`语句 (3)` 的频度不仅与问题规模 `n` 有关，还与 `A` 的各元素值及 `k` 的取值有关。
> - 最坏情况：`A` 中没有与 `k` 相等的元素，则 `语句 (3)` 的频度 $ f(n) = n $。
> - 最好情况：`A` 中最后一个元素等于 `k`，则 `语句 (3)` 的频度 $ f(n) $ 是常数 $ 0 $。


---


