# 2.5 顺序表与链表的综合比较

## 2.5.1 顺序表和链表的比较

<br>

### 基于空间的考虑
顺序表的存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模。若线性表的长度变化较大，则存储规模难以预先确定。估计过大则造成空间浪费，估计太小又可能导致空间溢出。**当线性表的长度变化较大、难以估计其存储规模时，采用动态链表作为存储结构较好**。

**存储密度（Storage Density）**，是指**结点数据本身所占的存储量和整个结点结构所占的存储量之比**。链表中的每个结点，除了数据域外，还要额外设置指针（或游标）域，从存储密度来讲，这是不经济的。

**一般地，存储密度越大,存储空间的利用率就越高**。显然，**顺序表的存储密度为 $1$ ，而链表的存储密度小于 $1$** 。
> 例如，单链表中各结点的数据均为整数，指针所占空间和整型量相同，则单链表的存储密度为 $50\%$ 。因此若不考虑顺序表中的备用结点空间，则顺序表的存储空间利用率为 $100\%$ ，而单链表的存储空间利用率为 $50\%$ 。

由此可知，**当线性表的长度变化不大、易于事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构**。

<br>

### 基于时间的考虑
顺序表是由向量实现的，它是一种随机存取结构，对表中任一结点都可以在 $O(1)$ 时间内直接地存取，而链表中的结点则需从头指针起顺着链查找才能取得。因此，**若线性表的操作主要是进行查找，很少做插入或删除操作，宜采用顺序表作为存储结构**。

在链表中的任何位置上进行插入或删除，都只需要修改指针。而在顺序表中进行插入或删除时，平均要移动表中近一半的结点，尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。因此，**对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构**。**若表的插入或删除操作主要发生在表的首尾两端，则宜采用带尾指针的单循环链表**。

<br>

### 基于语言的考虑
在没有提供指针类型的高级语言环境中，若要采用链表结构，则可以使用游标来实现静态链表。虽然静态链表在存储分配上有不足之处，但它和动态链表一样，具有插入和删除方便的特点。

**值得一提的是，即使是对那些具有指针类型的语言，静态链表也有其用武之地。特别是当线性表的长度不变，仅需改变结点之间的相对关系时，静态链表比动态链表可能更方便。**


---


## 2.5.2 线性表链式存储方式的比较

|         操作名称→<br>链表名称↓         |           找表中首元素结点           |            找表尾结点           |                        找 `P` 结点前驱结点                        |
|:--------------------------------------:|:------------------------------------:|:-------------------------------:|:-----------------------------------------------------------------:|
|             带头结点单链表 `L`         |    `L->next` <br> 时间耗费 $O(1)$    |  一重循环 <br> 时间耗费 $O(n)$  |            顺 `P` 结点的 next 域无法找到 `P` 结点的前驱           |
| 带头结点循环单链表 <br> （头指针） `L` |    `L->next` <br> 时间耗费 $O(1)$    |  一重循环 <br> 时间耗费 $O(n)$  | 顺 `P` 结点的 next 域可以找到 `P` 结点的前驱 <br> 时间耗费 $O(n)$ |
|        带尾指针的循环单链表 `R`        | `R->next->next` <br> 时间耗费 $O(1)$ |     `R` <br> 时间耗费 $O(1)$    | 顺 `P` 结点的 next 域可以找到 `P` 结点的前驱 <br> 时间耗费 $O(n)$ |
|        带头结点双向循环链表 `L`        |    `L->next` <br> 时间耗费 $O(1)$    | `L->proir` <br> 时间耗费 $O(1)$ |                  `R->proir` <br> 时间耗费 $O(1)$                  |
