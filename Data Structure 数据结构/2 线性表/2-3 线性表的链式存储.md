# 2.3 线性表的链式存储
**链式存储是最常用的动态存储方法。**
为了克服顺序表的缺点，可以采用链式方式存储线性表。**通常将采用链式存储结构的线性表称为线性链表。**
- 从**链接方式**的角度看，链表可分为**单链表**、**循环链表**和**双链表**。
- 从**实现**角度看，链表可分为**动态链表**和**静态链表**。

## 2.3.1 单链表
在顺序表中，用一组地址连续的存储单元来依次存放线性表的结点，因此结点的逻辑顺序和物理顺序是一致的。而链表则不然，**链表是用一组任意的存储单元来存放线性表的结点，这组存储单元可以是连续的，也可以是非连续的，甚至是零散分布在内存的任何位置上**。

因此，**链表中结点的逻辑顺序和物理顺序不一定相同**。为了正确地表示结点间的逻辑关系，必须在存储线性表的每个数据元素值的同时，存储指示其后继结点的地址（或位置）信息，这两部分信息组成的存储映像称为**结点（Node）**。

- 单链表的结点结构：
  | data（数据域） | next（指针域） |
  |:-------------:|:-------------:|

结点包括两个域：
- **数据域**用来存储结点的值。
- **指针域**用来存储数据元素的直接后继的地址（或位置）。

线性链表正是通过每个结点的指针域将线性表的 $n$ 个结点按其逻辑顺序链接在一起的。由于此线性链表的每个结点只有一个 next 指针域，故将这种链表称为**单链表**。

单链表中每个结点的存储地址存放在其前驱节点的指针域中，由于线性表中的第一个结点无前驱，所以应设一个**头指针 H** 指向第一个结点。由于线性表的最后一个结点没有直接后继，则指定单链表的最后一个结点的指针域为“空”（**NULL**）。

单链表的头指针 H 标示着整个单链表的开始，习惯上用头指针代表单链表。给定单链表的头指针 H，即可顺着每个结点的 next 指针域得到单链表中的每个元素。因此对于整个单链表的操作必须从头指针开始。

例如，下图所示为线性表（A, B, C, D, E, F, G, H）的单链表存储结构，整个单链表的操作需从头指针 H 开始进行，顺着每个结点的指针域依次找到线性表的各个元素。

- 单链表的示例图：
  ![单链表的示例图](https://static.owo.cab/notes/image/cs/ds/chapter02/单链表的示例图.webp "单链表的示例图")

一般情况下，使用链表，只关心链表中结点间的逻辑顺序，并不关心每个结点的实际存储位置，因此通常用箭头来表示链域中的指针，于是链表就可以更直观地画成用箭头链接起来的结点序列。上图示例的单链表可表示为下图。

- 单链表的逻辑状态：
  ![单链表的逻辑状态](https://static.owo.cab/notes/image/cs/ds/chapter02/单链表的逻辑状态.webp "单链表的逻辑状态")

为了操作的统一、方便，可以在单链表的第一个结点之前附设一个**头结点**，头结点的数据域可以存储一些关于线性表的长度等附加信息，也可以不存储任何信息，对头结点数据域信息无特别规定，而头结点的指针域则用来存储指向第一个结点的指针（即第一个结点的存储位置）。此时**头指针**就不再指向表中第一个结点而是指向**头结点**。如果线性表为空表，则头结点的指针域为“空”，如下图所示。

- 带头结点单链表图示：
  ![带头结点单链表图示](https://static.owo.cab/notes/image/cs/ds/chapter02/带头结点单链表图示.webp "带头结点单链表图示")

**单链表的存储结构描述如下**：
```c
typedef struct Node     /* 结点类型定义 */
{
   ElemType data;
   struct Node * next;
} Node, * LinkList;     /* LinkList 为结构指针类型 */
```

`LinkList` 与 `Node *` 同为结构指针类型，这两种类型是**等价**的。通常习惯上用 `LinkList` 说明指针变量，强调它是某个单链表的头指针变量。例如，使用定义 `LinkList L` ，则 `L` 为单链表的头指针，从而提高程序的可读性。用 `Node *` 来定义指向单链表中结点的指针，例如， `Node * p` ，则 `p` 为指向单链表中结点的指针变量。

`L` 是单链表的头指针，它指向表中第一个结点（对于带头结点的单链表，则指向单链表的头结点），若 `L == NULL` （对于带头结点的单链表为 `L->next == NULL` ）表达式为真，则表示单链表为一个空表，其长度为 $0$ 。若是非空表，则可以通过头指针 `L` 访问表中结点，从而找到要访问的所有结点的数据信息。例如，对于带头结点的单链表 `L` ，令 `p = L->next` ，则 `p` 指向表中的第一个元素结点（也称**首元结点**），通过 `p->data` 就可以访问到表中第一个元素的数据值了。


---


## 2.3.2 单链表上的基本运算
以单链表作存储结构实现线性表的基本运算。

<br>

### 初始化单链表

**【算法描述】**
> ***算法：初始化单链表***
> ```c
> InitList(LinkList *L)
> {
>     *L = (Linklist)malloc(sizeof(Node));    /* 建立头结点 */
>     (*L)->next = NULL;                      /* 建立空的单链表 L */
> }
> ```
**注意**： `L` 是指向单链表的头结点的指针，用来接收主程序中待初始化单链表的头指针变量的地址， `*L` 相当于主程序中待初始化单链表的头指针变量。

<br>

### 建立单链表
假设线性表中结点的数据类型是字符，逐个输入这些字符，并以 `$` 作为输入结束标志符。
常见的建表方法有如下两种。

- **头插法建表**
  **【算法思想】**
  从一个空表开始，每次读入数据，生成新结点，将读入数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头结点之后，直至读入结束标志为止。头插法建立单链表过程如图所示。

    - 头插法建立单链表图示：
      ![头插法建立单链表图示](https://static.owo.cab/notes/image/cs/ds/chapter02/头插法建立单链表图示.webp "头插法建立单链表图示")

  **【算法描述】**
  > ***算法：用头插法建立单链表***
  > ```c
  > void CreateFromHead(LinkList L)
  > /* L 是带头结点的空链表头指针，通过键盘输入表中元素值，利用头插法建单链表 L */
  > {
  >     Node * s;
  >     char c;
  >     int flag = 1;
  >     while (flag)    /* flag 初值为 1，当输入 "$" 时，置 flag 为 0，建表结束 */
  >     {
  >         c = getchar();
  >         if (c != '$')
  >         {
  >             s = (Node *)malloc(sizeof(Node));   /* 建立新结点 s */
  >             s->data = c;
  >             s->next = L->next;                  /* 将 s 结点插入表头 */
  >             L->next = s;
  >         }
  >         else
  >             flag = 0;
  >     }
  > }
  > ```
  采用头插法得到的单链表的逻辑顺序**与输入元素顺序相反**，亦称**头插法建表**为**逆序建表法**。
  **注意**：在上述算法中， `L` 是指向单链表的头指针，习惯上称为单链表 `L` 。

<br>

- **尾插法建表**
  **【算法思想】**
  头插法建立链表虽然算法简单，但生成的链表中结点的次序和输入的顺序相反。若希望二者顺序一致，可采用尾插法建表。该方法是将新结点插到当前单链表的表尾上。为此需增加一个尾指针 `r` ，使之指向当前单链表的表尾。尾插法建立单链表过程如图所示。

    - 尾插法建立单链表图示：
      ![尾插法建立单链表图示](https://static.owo.cab/notes/image/cs/ds/chapter02/尾插法建立单链表图示.webp "尾插法建立单链表图示")

  **【算法描述】**
  > ***算法：用尾插法建立单链表***
  > ```c
  > void CreateFromTail(LinkList L)
  > /* L 是带头结点的空链表头指针，通过键盘输入元素值，利用尾插法建单链表 L */
  > {
  >     Node * r, * s;
  >     int flag = 1;     /* 设置一个标志，初值为 1，当输入 "$" 时，flag 为 0，建表结束 */
  >     r = L;            /* r 指针动态指向链表的当前表尾，以便于做尾插入，其初值指向头结点 */
  >     while (flag)      /* 循环输入表中元素值，将建立新结点 s 插入表尾 */
  >     {
  >         c = getchar();
  >         if (c != '$')
  >         {
  >             s = (Node *)malloc(sizeof(Node));
  >             s->data = c;
  >             r->next = s;
  >             r = s;
  >         }
  >         else
  >         {
  >             flag = 0;
  >             r->next = NULL; /* 将最后一个结点的 next 链域置为空，表示链表的结束 */
  >         }
  >     } /* while */
  > } /* CreateFromTail */
  > ```

<br>

### 查找
1. **按序号查找**
   **【算法思想】**
   在单链表中，由于每个结点的存储位置都放在其前一结点的 next 域中，所以即使知道被访问结点的序号 $i$ ，也不能像顺序表那样直接按序号 $i$ 访问一维数组中的相应元素，实现随机存取，而只能从链表的头指针出发，顺链域 next 逐个结点往下搜索，直至搜索到第 $i$ 个结点为止。

   要查找带头结点的单链表中第 $i$ 个结点，则需要从单链表的头指针 `L` 出发，从头结点（`L->next`）开始顺着链域扫描，用指针 `p` 指向当前扫描到的结点，初值指向头结点，用 `j` 做计数器，累计当前扫描过的结点数（初值为 $0$ ），当 `j == i` 时，指针 `p` 所指的结点就是要找的第 $i$ 个结点。

   **【算法描述】**
   > ***算法：在单链表 `L` 中查找第 $i$ 个结点***
   > ```c
   > Node * Get(LinkList L, int i)
   > /* 在带头结点的单链表 L 中查找第 i 个结点（1 <= i <= n），
   >    若找到，则返回该结点的存储位置；否则返回 NULL */
   > {
   >     int j;
   >     Node * p;
   >     if (i <= 0)
   >         return NULL;
   >     p = L;
   >     j = 0;                /* 从头结点开始扫描 */
   >     while ((p->next != NULL) && (j < i))
   >     {
   >         p = p->next;      /* 扫描下一结点 */
   >         j++;              /* 已扫描结点计数器 */
   >     }
   >     if (i == j)
   >         return p;         /* 找到了第 i 个结点 */
   >     else
   >         return NULL;      /* 找不到，i <= 0 或 i > n */
   > } /* Get */
   > ```

<br>

2. **按值查找**
   **【算法思想】**
   按值查找是指在单链表中查找是否有值等于 $e$ 的结点。查找过程从单链表的头指针指向的头结点出发，顺链逐个将结点值和给定值 $e$ 作比较，返回查找结果。

   **【算法描述】**
   > ***算法：在单链表 `L` 中查找值为 `key` 的结点***
   > ```c
   > Node * Locate(LinkList L, ElemType key)
   > /* 在带头结点的单链表 L 中查找其结点值等于 key 的第一个结点，
   >    若找到则返回该结点的位置 p，否则返回 NULL */
   > {
   >     Node * p;
   >     p = L->next;          /* 从表中第一个结点开始 */
   >     while (p != NULL)     /* 当前表未查完 */
   >     {
   >         if (p->data != key)
   >             p = p->next;
   >         else
   >             break;        /* 找到结点值 = key 时退出循环 */
   >     }
   >     return p;
   > } /* Locate */
   > ```

**这两个算法的平均时间复杂度均为 $O(n)$ 。**

<br>

### 求单链表长度操作
**【算法思想】**
采用“数”结点的方法求出带头结点单链表的长度。即从“头”开始“数”（ `p = L->next` ），用指针 `p` 依次指向各个结点，并附设计数器 `j` 计数，一直“数”到最后一个结点（ `p->next == NULL` ），从而得到单链表的长度。

**【算法描述】**
> ***算法：求单链表的长度***
> ```c
> int ListLength(LinkList L)
> /* 求带头结点的单链表 L 的长度 */
> {
>     Node * p;
>     p = L->next;
>     j = 0;          /* 用来存放单链表的长度 */
>     while (p != NULL)
>     {
>         p = p->next;
>         j++;
>     }
>     return j;       /* j 为求得的单链表长度 */
> } /* ListLength */
> ```

若单链表 `L` 为空表， `p` 的初值为 `NULL` ，算法中 `while` 循环未执行，则返回链表长度 `j` 为 $0$ 。
若单链表 `L` 为非空表，算法中 `while` 循环执行次数为表长度 `n` ，故**算法的时间复杂度为 $O(n)$** 。

<br>

### 单链表插入操作
**【问题要求】**
在线性表的第 $i$ （ $1 ≤ i ≤ n+1$ ）个位置之前插入一个新元素 $e$ 。

**【算法思想】**
插入过程分为以下三步。
1. **查找**：在单链表中找到第 $i-1$ 个结点并由指针 `pre` 指示。
2. **申请**：申请新结点 `s` ，将其数据域的值置为 $e$ 。
3. **插入挂链**：通过修改指针域将新结点 `s` 挂入单链表 `L` 。

**【结果】**
将长度为 $n$ 的线性表（ $a_1, \cdots , a_{i-1}, a_i, \cdots , a_n$ ）变成长度为 $n + 1$ 的线性表（ $a_1, \cdots , a_{i-1}, a, a_i, \cdots , a_n$ ）。

单链表插入结点的过程如图所示。

- 在单链表第i个结点前插入一个结点的过程：
  ![在单链表第i个结点前插入一个结点的过程](https://static.owo.cab/notes/image/cs/ds/chapter02/在单链表第i个结点前插入一个结点的过程.webp "在单链表第i个结点前插入一个结点的过程")

**【算法描述】**
> ***算法：单链表插入操作***
> ```c
> void InsList(LinkList L, int i, ElemType e)
> /* 在带头结点的单链表 L 中第 i 个位置插入值为 e 的新结点 */
> {
>     Node * pre, * s;
>     int k;
>     if (i <= 0)
>         return ERROR;
>     pre = L;
>     k = 0;                  /* 从“头”开始，查找第 i - 1 个结点 */
>     while ((pre != NULL) && (k < i - 1))    /* 表未查完且未查到第 i - 1 个时重复，找到 pre 指向第 i - 1 个 */
>     {
>         pre = pre->next;
>         k = k + 1;
>     }                       /* 查找第 i - 1 个结点 */
>     if (pre == NULL)        /* 如当前位置 pre 为空表示已找完，但还未数到第 i 个，说明插入位置不合理 */
>     {
>         printf("插入位置不合理！");
>         return ERROR;
>     }
>     s = (Node *)malloc(sizeof(Node));   /* 申请一个新的结点 s */
>     s->data = e;                        /* 值 e 置入 s 的数据域 */
>     s->next = pre->next;                /* 修改指针，完成插入操作 */
>     pre->next = s;
>     return OK;
> }
> ```

**说明**：若单链表中有 $m$ 个结点，则按头插法操作时插入位置有 $m + 1$ 个即 $1 ≤ i ≤ m + 1$ 。当 $i = m + 1$ 时，则认为是在单链表的尾部插入一个结点。

<br>

### 单链表删除操作
**【问题要求】**
将线性表的第 $i$ （ $1 ≤ i ≤ n + 1$ ）个元素 $e$ 删除。

**【算法思想】**
删除过程分为以下两步。
1. **查找**：通过计数方式找到第 $i - 1$ 个结点并由指针 `pre` 指示。
2. **删除第 $i$ 个结点并释放结点空间**。

**【结果】**
将长度为 $n$ 的线性表（ $a_1, \cdots , a_{i-1}, a_i, \cdots ,a_n$ ）变成长度为 $n - 1$ 的线性表（ $a_1, \cdots , a_{i-1}, a_{i+1}, \cdots , a_n$ ）单链表删除操作过程如图所示。

- 单链表的删除过程：
  ![单链表的删除过程](https://static.owo.cab/notes/image/cs/ds/chapter02/单链表的删除过程.webp "单链表的删除过程")

**【算法描述】**
> ***算法：单链表删除操作***
> ```c
> int DelList(LinkList L, int i, ElemType *e)
> /* 在带头结点的单链表 L 中删除第 i 个元素，并将删除的元素保存到变量 *e 中 */
> {
>     Node * pre, * r;
>     int k;
>     pre = L;
>     k = 0;
>     while ((pre->next != NULL) && (k < i - 1))
>     /* 寻找被删除结点 i 的前驱结点 i - 1 使 p 指向它 */
>     {
>         pre = pre->next;
>         k = k + 1;
>     }                   /* 查找第 i - 1 个结点 */
>     if (pre->next == NULL)  /* while 循环是因为 p->next == NULL 或 i < 1 而跳出的，
>                                因为pre->next为空，没有找到合法的前驱位置，说明删除位置 i 不合法 */
>     {
>         printf("删除结点的位置 i 不合理！");
>         return ERROR;
>     }
>     r = pre->next;
>     pre->next = r->next;    /* 修改指针,删除结点 r */
>     *e = r->data;
>     free(r);                /* 释放被删除的结点所占的内存空间 */
>     return OK;
> }
> ```

**说明**：删除算法中的循环条件（ `pre->next != NULL && k < i - 1` ）与前插算法中的循环条件（ `pre != NULL && k < i - 1` ）不同，因为前插时的插入位置有 $m + 1$ 个（ $m$ 为当前单链表中数据元素的个数）。 $i = m + 1$ 是指在第 $m + 1$ 个位置前插入，即在单链表的末尾插入。而删除操作中删除的合法位置只有 $m$ 个，若使用与前插操作相同的循环条件，则会出现指针指空的情况，使删除操作失败。

<br>

**例 2.4** 有两个单链表 `LA` 和 `LB` ，其元素均为非递减有序排列，编写一个算法，将它们合并成一个单链表 `LC` ，要求 `LC` 也是非递减有序排列。要求：利用新表 `LC` 利用现有的表 `LA` 和 `LB` 中的元素结点空间，而不要额外申请结点空间。例如 $LA = (2, 2, 3)$ ， $LB = (1, 3, 3, 4)$ ，则 $LC = (1, 2, 2, 3, 3, 3, 4)$ 。

**【算法思想】**
要求利用现有的表 `LA` 和 `LB` 中的结点空间来建立新表 `LC` ，可通过更改结点的 next 域来重建新的元素之间的线性关系。为保证新表仍然递增有序，可以利用尾插入法建立单链表的方法，只是新建表中的结点不用 `malloc` ，而只要从表 `LA` 和 `LB` 中选择合适的点插入到新表 `LC` 中即可。

**【算法描述】**
***算法：合并两个有序的单链表***
```c
LinkList MergeLinkList(LinkList LA, LinkList LB)
/* 将递增有序的单链表 LA 和 LB 合并成一个递增有序的单链表 LC */
{
    Node * pa, * pb;
    LinkList LC;
    /* 将 LC 初始置空表。pa 和 pb 分别指向两个单链表 LA 和 LB
       中的第一个结点，r 初值为 LC 且 r 始终指向 LC 的表尾 */
    pa = LA->next;
    pb = LB->next;
    LC = LA;
    LC->next = NULL;
    r = LC;
    /* 当两个表中均未处理完时，比较选择将较小值结点插入到新表 LC 中。 */
    while ((pa != NULL) && (pb != NULL))
    {
        if (pa->data <= pb->data)
        {
            r->next = pa;
            r = pa;
            pa = pa->next;
        }
        else
        {
            r->next = pb;
            r = pb;
            pb = pb->next;
        }
    }
    if (pa) /* 若表 LA 未完，将表 LA 中后续元素链到新表 LC 表尾 */
        r->next = pa;
    else    /* 否则将表 LB 中后续元素链到新表 LC 表尾 */
        r->next = pb;
    free(LB);
    return LC;
} /* MergeLinkList */
```

---


## 2.3.3 循环链表
**循环链表（Circular Linked List）是一个首尾相接的链表。** 将单链表最后一个结点的指针域由 `NULL` 改为指向表头结点，就得到了单链形式的循环链表，并称为循环单链表。同样还可以有多重链的循环链表。

在循环单链表中，表中所有结点都被链在一个环上，为使某些操作实现方便，在循环单链表中也可设置一个头结点。这样，空循环链表仅由一个自成循环的头结点表示。带头结点的循环单链表如图所示。

- 带头结点循环单链表：
  ![带头结点循环单链表](https://static.owo.cab/notes/image/cs/ds/chapter02/带头结点循环单链表.webp "带头结点循环单链表")

带头结点的循环单链表与带头结点的单链表的实现算法类似，**差别仅在于算法中判别当前结点 `p` 是否为表尾结点的条件不同**。单链表中判别条件为 `p != NULL` 或 `p->next != NULL` ，而单循环链表的判别条件则是 `p != L` 或 `p->next != L` 。

**在循环单链表中附设尾指针有时比附设头指针会使操作变得更简单**。例如，在用头指针表示的循环单链表中，找开始结点 $a_1$ 的时间复杂度是 $O(1)$ ，然而要找到终端结点 $a_n$ ，则需要从头指针开始遍历整个链表，其时间复杂度是 $O(n)$ 。如果用尾指针 rear 来表示循环单链表，则**查找开始结点和终端结点都很方便，它们的存储位置分别是 `rear->next->next` 和 `rear`** ，显然，查找时间复杂度都是 $O(1)$ 。因此，**实用中多采用尾指针表示循环单链表**。

<br>

### 初始化循环单链表
```c
InitCLinkList(LinkList * CL)
/* CL 用来接收待初始化的循环单链表的头指针变量的地址 */
{
    *CL = (LinkList)malloc(sizeof(Node));   /* 建立头结点 */
    (*CL)->next = *CL;                      /*建立空的循环单链表 CL*/
}
```

<br>

### 建立循环单链表
假设线性表中结点的数据类型是字符，逐个输入这些字符，并以 `$` 作为输入结束标志符。
```c
void CreateCLinkList(LinkList CL)
/* CL 是已经初始化好的、带头结点的空循环链表的头指针，通过键盘输入元素值，利用尾插法建立循环单链表 CL */
{
    Node * rear, * s;
    char c;
    rear = CL;          /* rear 指针动态指向链表的当前表尾，其初值指向头结点 */
    c = getchar();      /*读入第一个元素*/
    while (c != '$')    /* 只要读入的元素不是结束标志，就存入新结点 s 并链到表尾，直到读入结束标志 */
    {
        s = (Node *)malloc(sizeof(Node));
        s->data = c;
        rear->next = s;
        rear = s;
        c = getchar();
    }
    rear->next = CL;    /* 让最后一个结点的 next 链域指向头结点 */
}
```

<br>

**例 2.5** 有两个带头结点的循环单链表 `LA` 、 `LB` ，编写算法，将两个循环单链表合并为一个循环单链表，其头指针为 `LA` 。

**【算法思想】**
先找到两个链表 `LA` 、 `LB` 的表尾，并分别由指针 `p` 、 `q` 指向它们，然后将第一个链表的尾与第二个表的第一个结点链接起来，并修改第二个表的表尾 `q` ，使它的链域指向第一个表的头结点。

**【算法描述】**
> ***算法：循环单链表的合并算法（1）***
> ```c
> LinkList merge_1(LinkList LA, LinkList LB)
> /* 此算法将两个采用头指针的循环单链表的首尾连接起来 */
> {
>     Node * P, * q;
>     p = LA;
>     q = LB;
>     while (p->next != LA)
>         p = p->next;    /* 找到表 LA 的表尾，用 p 指向它 */
>     while (q->next != LB)
>         q = q->next;    /* 找到表 LB 的表尾，用 q 指向它 */
>     q->next = LA;       /* 修改表 LB 的尾指针，使之指向表 LA 的头结点 */
>     p->next = LB->next; /* 修改表 LA 的尾指针，使之指向表 LB 中的第一个结点 */
>     free(LB);
>     return LA;
> }
> ```

**采用上面的方法，需要遍历链表，找到表尾，其执行时间是 $O(n)$ 。**

若单循环链表设置**尾指针**表示，在实现上述合并时，**无须循环遍历找尾结点，只需要直接修改尾结点的指针域，其执行时间是 $O(1)$ 。**

**【算法描述】**
> ***算法：循环单链表的合并算法（2）***
> ```c
> LinkList merge_2(LinkList RA, LinkList RB)
> /* 此算法将两个采用尾指针的循环链表首尾连接起来 */
> {
>     Node * p;
>     p = RA->next;     /* 保存链表 RA 的头结点地址 */
>     RA->next = RB->next->next;    /* 链表 RB 的开始结点链到链表 RA 的终端结点之后 */
>     free(RB->next);   /* 释放链表 RB 的头结点 */
>     RB->next = p;     /* 链表 RA 的头结点链到链表 RB 的终端结点之后 */
>     return RB;        /* 返回新循环链表的尾指针 */
> }
> ```


---


## 2.3.4 双向链表
循环单链表虽然能够实现从任一结点出发沿着链能找到其前驱结点，但时间耗费是 $O(n)$ 。如果希望从表中快速确定某一个结点的前驱，另一个解决方法就是在单链表的每个结点里再增加一个指向其前驱的指针域 prior。这样形成的链表中就**有两条方向不同的链，称之为双（向）链表（Double Linked List）**。双链表的结点结构如图所示。

- 双链表的结点结构
  | prior（前驱指针域） | data（数据域） | next（后继指针域） |
  |:------------------:|:-------------:|:-----------------:|

**双链表的结构定义如下**：
```c
typedef struct DNode
{
    ElemType data;
    struct DNode * prior, * next;
} DNode, * DoubleList;
```

与单链表类似，双链表也可增加头结点使双链表的某些运算变得方便。同时**双向链表也可以有循环表，称为双向循环链表**，其结构如图所示。

- 双向循环链表图示
  ![双向循环链表图示](https://static.owo.cab/notes/image/cs/ds/chapter02/双向循环链表图示.webp "双向循环链表图示")

由于**在双向链表中既有前向链又有后向链**，寻找任一个结点的直接前驱结点与直接后继结点都变得非常方便了。

设指针 `p` 指向双链表中某一结点，则有下式成立：
```c
p->prior->next == p
p == p->next->prior
```

在双向链表中，那些**只涉及后继指针的算法**，如求表长度、取元素、元素定位等，**与单链表中相应的算法相同**；但**对于涉及前驱和后继两个方向指针变化的操作**，则**与单链表中的实现算法不同**。

<br>

### 双向链表的前插操作
**【算法思想】**
欲在双向链表第i个结点之前插入一个的新的结点，则指针的变化情况如图所示。

- 双向链表插入操作
  ![双向链表插入操作](https://static.owo.cab/notes/image/cs/ds/chapter02/双向链表插入操作.webp "双向链表插入操作")

**【算法描述】**
> ***算法：双向链表的插入操作***
> ```c
> int DlinkIns(DoubleList L, int i, ElemType e)
> {
>     DNode * s, * p;
>     // ...  /* 先检查待插入的位置 i 是否合法（实现方法同单链表的前插操作） */
>     // ...  /* 若位置 i 合法，则找到第 i 个结点并让指针 p 指向它 */
>     s = (DNode *)malloc(sizeof(DNode));
>     if (s)
>     {
>         s->data = e;
>         s->prior = p->prior;    /* ① */
>         p->prior->next = s;     /* ② */
>         s->next = p;            /* ③ */
>         p->prior = s;           /* ④ */
>         return TRUE;
>     }
>     else
>         return FALSE;
> }
> ```

<br>

### 双向链表的删除操作
**【算法思想】**
欲删除双向链表中的第 $i$ 个结点，则指针的变化情况如图所示。

- 双向链表的删除操作
  ![双向链表的删除操作](https://static.owo.cab/notes/image/cs/ds/chapter02/双向链表的删除操作.webp "双向链表的删除操作")

**【算法描述】**
> ***算法：双向链表的删除操作***
> ```c
> int DlinkDel(DoubleList L, int i, ElemType *e)
> {
>     DNode *p;
>     // ... /* 先检查待插入的位置 i 是否合法（实现方法同单链表的删除> 操作） */
>     // ... /* 若位置 i 合法，则找到第 i 个结点并让指针 p 指向它 */
>     *e = p->data;
>     p->prior->next = p->next;       /* ① */
>     p->next->prior = p->prior;      /* ② */
>     free(p);
>     return TRUE;
> }
> ```


---


## \*2.3.5 静态链表
用于没有“指针”数据类型的高级语言，如 BASIC、FORTRAN，以便采用顺序存储结构数组模拟实现链表。在此不作具体讨论。
