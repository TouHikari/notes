# 2.2 线性表的顺序存储

## 2.2.1 线性表的顺序存储结构

线性表的顺序结构是指用一组地址连续的存储单元一次存储线性表中的各个元素，使得线性表中在逻辑上相邻的数据元素存储在连续的物理存储单元中，即通过数据元素物理存储的连续性来反映数据元素之间逻辑上的相邻关系。

采用顺序存储结构存储的线性表通常简称为**顺序表**。可将**顺序表**归纳为：**关系线性化，结点顺序存**。

在顺序表中，每个结点 $a_i$ 存储地址是该结点在表中的逻辑位置 $i$ 的线性函数，只要知道线性表中第一个元素的存储地址（基地址）和表中每个元素所占存储单元的多少，就可以计算出线性表中任意一个数据元素的存储地址，从而实现对顺序表中数据元素的随机存取。

<br>

### 地址的计算

假设线性表中有 $n$ 个元素，每个元素占 $k$ 个单元，第一个元素的地址为 $Loc(a_1)$ ，则可通过如下公式计算出第 $i$ 个元素的地址 $Loc(a_i)$ ：

$$Loc(a_i) = Loc(a_1) + (i-1)×k$$

其中， $Loc(a_1)$ 称为基地址。

<br>

### 线性表顺序存储的表示

可借助于高级程序设计语言中的一位数组来表示，一维数组的下标与元素在线性表中的序号相对应。

在 C 语言定义线性表的顺序存储结构如下：
```c
#define MAXSIZE 100         /* 此处的宏定义常量表示线性表的最大长度 */
typedef struct {
    ElemType elem[MAXSIZE]; /* 线性表占用的数组空间 */
    int last;               /* 记录线性表中最后一个元素在数组 elem[] 中的位置
                              （下标值），空表置为 -1 */
} SeqList
```

说明：
1. 结点类型定义中 `ElemType` 数据类型是为了描述的统一而自定的，在实际应用中可以根据需要来具体定义顺序表中元素的数据类型，如 `int` 、 `char` 、 `float` 或是一种 `struct` 结构类型。
2. 从数组中起始下标为 0 处开始存放线性表中第一个元素，因此元素序号与其在数组中的下标位置之间相差 1。

利用定义的顺序表的数据类型 `SeqList` 就可以定义变量了。变量 `L` 的定义与使用方法有以下两种：
1. 通过变量定义语句
   ```c
   SeqList L;
   ```
   将 `L` 定义为 `SeqList` 类型的变量，利用 `L.elem[i-1]` 来访问顺序表中序号为 $i$ 的元素 $a_i$ ；
   通过 `L.last` 可得到顺序表中最后一个元素的下标，而 `L.last + 1` 就是顺序表的长度。
2. 通过指针变量定义语句
   ```c
   SeqList L1, *L;
   L = &L1;
   ```
   将 `L` 定义为指向 `SeqList` 类型的指针变量，使用时，可通过 `L->elem[i - 1]` 来访问顺序表中序号为 $i$ 的元素 $a_i$ ，使用 `L->last + 1` 则得到顺序表的长度。


---


## 2.2.2 线性表顺序存储结构上的基本运算

<br>

### 查找操作

线性表有两种基本的查找运算。

1. **按序号查找 $GetData(L, i)$**：查找顺序表 $L$ 中第 $i$ 个数据元素。
   核心语句为 `L.elem[i - 1]` 。

2. **按内容查找 $Locate(L, e)$**：要求查找顺序表 $L$ 中与给定值 $e$ 相等的数据元素。
   在顺序表 $L$ 中找到与 $e$ 相等的元素，则返回该元素在表中的序号；
   若找不到，则返回一个“空序号”标识，如 $-1$ 。

**【算法思想】**
查找运算可采用顺序查找，即从第一个元素开始，一次将表中元素与 $e$ 相比较，若相等，则查找成功，返回该元素在表中的序号；若 $e$ 与表中的所有元素都不相等，则查找失败，返回 $-1$ 。

**【算法描述】**
> ***算法：顺序表的按内容查找运算***
> ```c
> int Locate(SeqList L, ElemType e)
> /* 在顺序表 L 中查找与 e 相等的元素，若 L.elem[i] = e，
>    则找到该元素，并返回 i + 1，若找不到，则返回-1 */
> {
>     i = 0;              /* i 为扫描计数器，初值为 0，即从第一个元素开始比较 */
>     while ((i <= L.last) && (L.elem[i] != e))   /* 顺序扫描表，直到找到值为 e 的元素，
>                                                    或扫描到表尾而没有找到 */
>         i++;
>     if (i < L.last)
>         return i + 1;   /* 若找到值为 e 的元素，则返回其序号 */
>     else
>         return -1;      /* 若没找到，则返回空序号 */
> }
> ```

**该算法的时间复杂度为 $O(n)$ 。**

<br>

### 插入操作

线性表的插入运算是指在表的第 $i(1 ≤ i ≤ n+1)$ 个位置前插入一个新元素 $e$ ，使长度为 $n$ 的线性表 $(e_1, ..., e_{i-1}, e_i, ..., e_n)$ 变成长度为 $n + 1$ 的线性表 $(e_1, ..., e_{i-1}, e, e_i, ..., e_n)$ （其中 $n$ 为 $L$ 的表长度）。

**【算法思想】**
用顺序表作为线性表的存储结构时，由于结点的物理顺序必须和结点的逻辑顺序保持一致，因此必须将原表中位置 $n, n-1, ..., i$ 上的结点，依次后移到位置 $n+1, n, ..., i+1$ 上，空出第 $i$ 个位置，然后在该位置上插入新结点 $e$ 。当 $i = n + 1$ 时，是指在线性表的末尾插入结点，所以无须移动结点，直接将 $e$ 插入表的末尾即可。

**例 2.1** 已知线性表 $(4, 9, 15, 28, 30, 30, 42, 51, 62)$ ，在第四个元素之前插入一个元素 $“21”$ 。
**【分析】** 如果在第四个元素前插入一个元素，则需将第九个位置到第四个位置的元素依次后移一个位置，然后将 $“21”$ 插入到第四个位置。

1. 移动前顺序表的状态：

| 1 | 2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 |
|:-:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
| 4 | 9 | 15 | 28 | 30 | 30 | 42 | 51 | 62 |    |

2. 移动后顺序表的状态：

| 1 | 2 |  3 | 4 |   5  |   6  |   7  |   8  |   9  |  10  |
|:-:|:-:|:--:|:-:|:----:|:----:|:----:|:----:|:----:|:----:|
| 4 | 9 | 15 |   | _28_ | _30_ | _30_ | _42_ | _51_ | _62_ |

3. 插入后顺序表的状态：

| 1 | 2 |  3 |     4    |   5  |   6  |   7  |   8  |   9  |  10  |
|:-:|:-:|:--:|:--------:|:----:|:----:|:----:|:----:|:----:|:----:|
| 4 | 9 | 15 | **_21_** | _28_ | _30_ | _30_ | _42_ | _51_ | _62_ |

**【算法描述】**
> ***算法：顺序表的插入运算***
> ```c
> #define OK 1
> #define ERROR 0
> int InsList(SeqList *L, int i, ElemType e)
> /* 在顺序表 L 中第 i 个数据元素之前插入一个元素 e。i 的合法取值范围是 1 <= i <= L->last + 2 */
> {
>     int k;
>     if ((i < 1) || (i > L->last + 2))   /* 首先判断插入位置是否合法 */
>     {
>         printf("表已满，无法插入");
>         return ERROR;
>     }
>     for (k = L->last; k >= i - 1; k--)  /* 为插入元素而移动位置 */
>         L->elem[k + 1] = L->elem[k];
>     L->elem[i - 1] = e;                 /* 第 i 个元素的下标为 i - 1 */
>     L->last++;
>     return OK;
> }
> ```

**【算法分析】**
当在表尾（ `i == L->last+2` ）插入元素时，因为循环的终值大于初值，此时不需要移动元素，可直接在表尾插入 `e` 。当在表头（ `i == 1` ）插入时，移动元素的语句 `L->elem[k + 1] = L->elem[k];` 需执行 $n$ 次，即将表中已存在的 $n$ 个元素依次后移一个位置才能将 `e` 插入。因此，语句 `L->elem[k + 1] = L->elem[k];` 的语句执行频度与插入位置 `i` 有关。
设 $E_{ins}$ 为在长度为 $n$ 的表中插入一元素所需移动元素的平均次数，假设 $P_i$ 为在第 $i$ 个元素之前插入元素的概率，并假设在任何位置上插入的概率相等，即 $P_i = \frac{1}{n + 1},\ i = 1, 2, ..., n+1$ ，则有

$$E_{ins} = \sum_{i=1}^{n+1} P_i (n-i+1) = \frac{1}{n+1} \sum_{i=1}^{n} (n-i+1) = \frac{1}{n+1} \sum_{k=1}^{n} k = \frac{n}{2} $$

<br>

### 删除操作

线性表的删除运算是指将表的第 $i(1 ≤ i ≤ n)$ 个元素删去，使长度为 $n$ 的线性表 $(e_1, ..., e_{i-1}, e_i, e_{i+1}, ..., e_n)$ ，变成长度为 $n-1$ 的线性表 $(e_1, ..., e_{i-1}, e_{i+1}, ..., e_n)$ 。

**【算法思想】**
用顺序表作为线性表的存储结构时，由于结点的物理顺序必须和结点的逻辑顺序保持一致，因此当需要删除第 $i$ 个元素时，必须将原表中位置在 $i+1, i+2, ..., n-1 , n$ 上的结点，依次前移到位置 $i, i+1, ..., n-1$ （其中 $n$ 为 $L$ 的表长度）。

**例 2.2** 删除线性表 $(4, 9, 15, 21, 28, 30, 30, 42, 51, 62)$ 第五个元素。
**【分析】** 如果要删除第五个元素，则需将第六个元素到第十个元素依次向前移动一个位置。

1. 移动前顺序表的状态：

| 1 | 2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 |
|:-:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
| 4 | 9 | 15 | 28 | 30 | 30 | 42 | 51 | 62 |    |

2. 删除后顺序表的状态：

| 1 | 2 |  3 |   4  |   5  |   6  |   7  |   8  | 9 | 10 |
|:-:|:-:|:--:|:----:|:----:|:----:|:----:|:----:|:-:|:--:|
| 4 | 9 | 15 | _30_ | _30_ | _30_ | _42_ | _51_ |   |    |

**【算法描述】**
> ***算法：顺序表的删除运算***
> ```c
> int DelList(SeqList *L, int i, ElemType *e)
> /* 在顺序表 L 中删除第 i 个数据元素，并用指针参数 e 返回其值。
>    i 的合法取值为1 <= i <= L->last + 1 */
> {
>     int k;
>     if ((i < 1) || (i > L->last + 1))
>     {
>         printf("删除位置不合法！");
>         return ERROR;
>     }
>     *e = L->elem[i - 1];                /* 将删除的元素存放到 e 所指向的变量中 */
>     for (k = i; i <= L->last; k++)
>         L->elem[k - 1] = L->elem[k];    /* 将后面的元素依次前移 */
>     L->last--;
>     return OK;
> }
> ```

**【算法分析】**
与插入运算类似，在顺序表上实现删除运算也必须移动结点，这样才能维持线性表结点间的逻辑关系。当删除表尾（ `i == L->last + 1` ）元素时，因为循环变量的初值大于终值，此时不需要移动元素，仅将表长度减 $1$ 即可。当删除表头元素（ `i == 1` ）时，移动元素的语句 `L->elem[k + 1] = L->elem[k];` 需执行 $n - 1$ 次。因此删除算法中移位语句 `L->elem[k - 1] = L->elem[k];` 的执行频度与删除位置 `i` 有关。
设 $E_{del}$ 为删除一个元素所需移动元素的平均次数， $Q_i$ 为删除第 $i$ 个元素的概率，并假设在任何位置上删除的概率相等，即 $Qi = \frac{1}{n},\ i = 1, 2, ..., n$ 。则有

$$E_{del} = \sum_{i=1}^{n} Q_i (n-i) = \frac{1}{n} \sum_{i=1}^{n} (n-i) = \frac{1}{n} \sum_{k=0}^{n-1} k = \frac{n-1}{2}$$

<br>

**由以上分析可知，在顺序表中插入和删除一个数据元素时，其时间主要耗费在移动数据元素上。做一次插入或删除平均需要移动表中一半元素，当 $n$ 较大时算法效率较低。**

<br>

### 合并操作

**例 2.3** 有两个顺序表 $LA$ 和 $LB$ ，其元素均为非递减有序排列，编写算法，将它们合并成一个顺序表 $LC$ ，要求 $LC$ 也是非递减有序排列。例如， $LA = (2, 2, 3)$ ， $LB = (1, 3, 3, 4)$ ，则 $LC = (1, 2, 2, 3, 3, 3, 4)$ 。

**【算法思想】**
设表 $LC$ 是一个空表，为使 $LC$ 也是非递减有序排列，可设两个指针 `i` 、 `j` 分别指向表 $LA$ 和 $LB$ 中的元素，若 `LA.elem[i] > LB.elem[j]` ，则当前先将 `LB.elem[j]` 插入到表 $LC$ 中，若 `LA.elem[i] <= LB.elem[j]` ，则当前先将 `LA.elem[i]` 插入到表 $LC$ 中，如此进行下去，直到其中一个表被扫描完毕，然后再将未扫描完的表中剩余的所有元素放到表 $LC$ 中。

**【算法描述】**
> ***算法：线性表的合并运算***
> ```c
> void mergeList(SeqList *LA, SeqList *LB, SeqList *LC)
> {
>     int i = 0, j = 0, k = 0;
>     while ((i <= LA->last) && (j <= LB->last))
>     {
>         if (LA->elem[i] <= LB->elem[j])
>         {
>             LC->elem[k] = LA->elem[i];
>             i++;
>             k++;
>         }
>         else
>         {
>             LC->elem[k] = LB->elem[j];
>             j++;
>             k++;
>         }
>     }
>     while (i <= LA->last)   /* 当表 LA 有剩余元素时，则将表 LA 余下的元素赋给表 LC */
>     {
>         LC->elem[k] = LA->elem[i];
>         i++;
>         k++;
>     }
>     while (j <= LB->last)   /* 当表 LB 有剩余元素时，则将表 LB 余下的元素赋给表 LC */
>     {
>         LC->elem[k] = LB->elem[j];
>         j++;
>         k++;
>     }
>     LC->last = LA->last + LB->last + 1;
> }
> ```

**【算法分析】**
由于两个待归并的表 $LA$ 、 $LB$ 本身是值有序表，且表 $LC$ 的建立采用的是尾插法建表，插入时不需要移动元素，所以算法的时间复杂度 $O($ `LA->last` $+$ `LB->last` $)$ 。

<br>

由上面的讨论可知，线性表顺序表示的**优点**如下：
1. **无须为表示结点间的逻辑关系而增加额外的存储空间**（因为逻辑上相邻的元素其存储的物理位置也是相邻的）。
2. **可方便地随机存取表中的任一元素**，如 `GetData(L, i)` 操作。

线性表顺序表示的**缺点**如下：
1. **插入或删除运算不方便**，除表尾的位置外，在表的其他位置上进行插入或删除操作都必须移动大量的结点，其效率较低。
2. 由于顺序表要求占用连续的存储空间，**存储分配只能预先进行静态分配**。因此当表长变化较大时，**难以确定合适的存储规模**。若按可能达到的最大长度预先分配表空间，则可能造成一部分空间长期闲置而得不到充分利用；若事先对表长估计不足，则插入操作可能使表长超过预先分配的空间而造成溢出。
