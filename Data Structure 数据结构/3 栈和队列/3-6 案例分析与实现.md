## 3.6 案例分析与实现

在 3.2 节引入了 3 个有关栈应用的案例和一个有关队列应用的案例。本节对这四个案例作进一步的分析，然后分别利用栈和队列的基本操作给出案例中相关算法的具体实现。

- **案例 3.1：数制的转换**

  **【案例分析】**
  
  当将一个十进制整数 $N$ 转换为八进制数时，在计算过程中，把 $N$ 与 $8$ 求余得到的八进制数的各位依次进栈，计算完毕后将栈中的八进制数依次出栈输出，输出结果就是待求得的八进制数。
  
  **【案例实现】**
  
  在具体实现时，栈可以采用顺序存储表示也可以采用链式存储表示。
  
  > ***算法：数制的转换***
  > 
  > **【算法步骤】**
  > 
  > 1. 初始化一个空栈 `S` 。
  > 2. 当十进制数 `N` 非零时，循环执行以下操作：
  >    - 把 `N` 与 `8` 求余得到的八进制数压入栈 `S` ；
  >    - `N` 更新为 `N` 与 `8` 的商。
  > 3. 当栈 `S` 非空时，循环执行以下操作：
  >    - 弹出栈顶元素 `e` ;
  >    - 输出 `e` 。
  > 
  > **【算法描述】**
  > 
  > ```cpp
  > void conversion(int N)
  > {   // 对于任意一个非负十进制数，打印输出与其等值的八进制数
  >     InitStack(S);           // 初始化空栈 S
  >     while(N)                // 当 N 非零时，循环
  >     {
  >         Push(S, N % 8);     // 把 N 与 8 求余得到的八进制数压入栈 S
  >         N = N / 8;          // N 更新为 N 与 8 的商
  >     }
  >     while (!StackEmpty(S))  // 当栈 S 非空时，循环
  >     {
  >         Pop(s, e);          // 弹出栈顶元素 e
  >         cout << e;          // 输出 e
  >     }
  > }
  > ```

**【算法分析】**

该算法的时间和空间复杂度均为 $O(log_8n)$ 。

在实际利用栈的问题中，入栈和出栈操作大都不是单调的，而是交错进行的。下面的案例 3.2 和 3.3 都属于这种情况。

案例3.2：括号匹配的检验。
【案例分析】
检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号；每当读入一个右括号，若与当前栈顶的左括号类型相同，则二者匹配，将栈顶的左括号出栈，直到表达式扫描完毕。
在处理过程中，还要考虑括号不匹配出错的情况。例如，当出现(()[J)这种情况时，由于前面入栈的左括号均已和后面出现的右括号相匹配，栈已空，因此最后扫描的右括号不能得到匹配;出现[[1）这种错误，当表达式扫描结束时，栈中还有一个左括号没有匹配；出现（（）]这种错误显然是栈顶的左括号和最后的右括号不匹配。
【案例实现】
算法3.21括号的匹配
【算法步骤】
①初始化一个空栈S。