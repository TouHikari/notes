## 3.6 案例分析与实现

在 3.2 节引入了 3 个有关栈应用的案例和一个有关队列应用的案例。本节对这四个案例作进一步的分析，然后分别利用栈和队列的基本操作给出案例中相关算法的具体实现。

- **案例 3.1：数制的转换**

  **【案例分析】**
  
  当将一个十进制整数 $N$ 转换为八进制数时，在计算过程中，把 $N$ 与 $8$ 求余得到的八进制数的各位依次进栈，计算完毕后将栈中的八进制数依次出栈输出，输出结果就是待求得的八进制数。
  
  **【案例实现】**
  
  在具体实现时，栈可以采用顺序存储表示也可以采用链式存储表示。
  
  > ***算法：数制的转换***
  > 
  > **【算法步骤】**
  > 
  > 1. 初始化一个空栈 `S` 。
  > 2. 当十进制数 `N` 非零时，循环执行以下操作：
  >    - 把 `N` 与 `8` 求余得到的八进制数压入栈 `S` ；
  >    - `N` 更新为 `N` 与 `8` 的商。
  > 3. 当栈 `S` 非空时，循环执行以下操作：
  >    - 弹出栈顶元素 `e` ;
  >    - 输出 `e` 。
  > 
  > **【算法描述】**
  > 
  > ```cpp
  > void conversion(int N)
  > {   // 对于任意一个非负十进制数，打印输出与其等值的八进制数
  >     InitStack(S);           // 初始化空栈 S
  >     while(N)                // 当 N 非零时，循环
  >     {
  >         Push(S, N % 8);     // 把 N 与 8 求余得到的八进制数压入栈 S
  >         N = N / 8;          // N 更新为 N 与 8 的商
  >     }
  >     while (!StackEmpty(S))  // 当栈 S 非空时，循环
  >     {
  >         Pop(s, e);          // 弹出栈顶元素 e
  >         cout << e;          // 输出 e
  >     }
  > }
  > ```
  > 
  > **【算法分析】**
  > 
  > **该算法的时间和空间复杂度均为 $O(log_8n)$ 。**

在实际利用栈的问题中，入栈和出栈操作大都不是单调的，而是交错进行的。下面的案例 3.2 和 3.3 都属于这种情况。

<br>

- **案例 3.2：括号匹配的检验**
  
  **【案例分析】**
  
  检验算法借助一个栈，每当读入一个左括号，则直接入栈，等待相匹配的同类右括号；每当读入一个右括号，若与当前栈顶的左括号类型相同，则二者匹配，将栈顶的左括号出栈，直到表达式扫描完毕。
  
  在处理过程中，还要考虑括号不匹配出错的情况。例如，当出现 `(()[]))` 这种情况时，由于前面入栈的左括号均已和后面出现的右括号相匹配，栈已空，因此最后扫描的右括号不能得到匹配；出现 `[([])` 这种错误，当表达式扫描结束时，栈中还有一个左括号没有匹配；出现 `(()]` 这种错误显然是栈顶的左括号和最后的右括号不匹配。
  
  **【案例实现】**
  
  > <span id="算法：括号的匹配">***算法：括号的匹配***</span>
  > 
  > **【算法步骤】**
  > 
  > 1. 初始化一个空栈 `S` 。
  > 2. 设置一标记性变量 `flag` ，用来标记匹配结果以控制循环及返回结果， `1` 表示正确匹配， `0` 表示错误匹配， `flag` 初值为 `1` 。
  > 3. 扫描表达式，依次读入字符 `ch` ，如果表达式没有扫描完毕且 `flag` 非零，则循环执行以下操作：
  >    - 若 `ch` 是左括号 `[` 或 `(` ，则将其压入栈;
  >    - 若 `ch` 是右括号 `)` ，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是 `(` ，则正确匹配，否则错误匹配， `flag` 置为 `0` ;
  >    - 若 `ch` 是右括号 `]` ，则根据当前栈顶元素的值分情况考虑：若栈非空且栈顶元素是 `[` ，则正确匹配，否则错误匹配， `flag` 置为 `0` 。
  > 4. 退出循环后，如果栈空且 `flag` 值为 `1` ，则匹配成功，返回 `true` ，否则返回 `false` 。
  > 
  > **【算法描述】**
  > 
  > ```cpp
  > Status Matching(void)
  > {   // 检验表达式中所含括号是否正确匹配，如果匹配，则返回 true ，否则返回 false
  >     // 表达式以 # 结束
  >     InitStack(S);               // 初始化空栈
  >     flag = 1;                   // 标记匹配结果以控制循环及返回结果
  >     cin >> ch;                  // 读入第一个字符
  >     while (ch != '#' && flag)   // 假设表达式以 # 结尾
  >     {
  >         switch (ch)
  >         {
  >         case '[':               // 若是左括号，则将其压入栈
  >         case '(':
  >             Push(S, ch);
  >             break;
  >         case ')':               // 若是“)”，则根据当前栈顶元素的值分情况考虑
  >             if (!StackEmpty(S) && GetTop(S) == '(')
  >                 Pop(S, x);      // 若栈非空且栈顶元素是“(”，则正确匹配
  >             else
  >                 flag = 0;       // 若栈空或栈顶元素不是“(”，则错误匹配
  >             break;
  >         case ']':               // 若是“]”，则根据当前栈顶元素的值分情况考虑
  >             if (!StackEmpty(S) && GetTop(S) == '[')
  >                 Pop(S, x);      // 若栈非空且栈顶元素是“[”，则正确匹配
  >             else
  >                 flag = 0;       // 若栈空或栈顶元素不是“[”，则错误匹配
  >             break;
  >         } // switch
  >         cin >> ch;              // 继续读入下一个字符
  >     } // while
  >     if (StackEmpty(S) && flag)
  >         return true;            // 匹配成功
  >     else
  >         return false;           // 匹配失败
  > }
  > ```
  > 
  > **【算法分析】**
  > 
  > 此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为 $n$ ，则**此算法的时间复杂度为 $O(n)$** 。算法在运行时所占用的辅助空间主要取决于 `S` 栈的大小，显然， `S` 栈的空间大小不会超过 $n$ ，所以**此算法的空间复杂度也同样为 $O(n)$** 。

<br>

- **案例 3.3：表达式求值**
  
  **【案例分析】**
  
  任何一个表达式都是由操作数（operand）、运算符（operator）和界限符（delimiter）组成的，统称它们为单词。一般地，操作数既可以是常数，也可以是被说明为变量或常量的标识符；运算符可以分为算术运算符、关系运算符和逻辑运算符 3 类；基本界限符有左右括号和表达式结束符等。为了叙述的简洁，在此仅讨论简单算术表达式的求值问题，这种表达式只含加、减、乘、除4种运算符。读者不难将它推广到更一般的表达式上。
  
  下面把运算符和界限符统称为算符。
  
  我们知道，算术四则运算遵循以下 3 条规则：
  1. 先乘除，后加减；
  2. 从左算到右；
  3. 先括号内，后括号外。
  
  根据上述 3 条运算规则，在运算的每一步中，任意两个相继出现的算符 $\theta _1$ 和 $\theta _2$ 之间的优先关系，至多是下面 3 种关系之一：
  
  $$
  \begin{matrix}
   \theta _1 < \theta _2 & \theta _1 的优先权低于 \theta _2\\
   \theta _1 = \theta _2 & \theta _1 的优先权等于 \theta _2\\
   \theta _1 > \theta _2 & \theta _1 的优先权高于 \theta _2
  \end{matrix}
  $$
  
  下表定义了算符之间的这种优先关系。
  
  | $\theta _2$ → <br> $\theta _1$ ↓ | $+$ | $-$ | $*$ | $/$ | $($ | $)$ | $\#$ |
  |:------------------------------:|:---:|:---:|:---:|:---:|:---:|:---:|:----:|
  |                $+$               | $>$ | $>$ | $<$ | $<$ | $<$ | $>$ |  $>$ |
  |                $-$               | $>$ | $>$ | $<$ | $<$ | $<$ | $>$ |  $>$ |
  |                $*$               | $>$ | $>$ | $>$ | $>$ | $<$ | $>$ |  $>$ |
  |                $/$               | $>$ | $>$ | $>$ | $>$ | $<$ | $>$ |  $>$ |
  |                $($               | $<$ | $<$ | $<$ | $<$ | $<$ | $=$ |      |
  |                $)$               | $>$ | $>$ | $>$ | $>$ |     | $>$ |  $>$ |
  |               $\#$               | $<$ | $<$ | $<$ | $<$ | $<$ |     |  $=$ |
  
  由规则 1，先进行乘除运算，后进行加减运算，所以有 `+` $<$ `*` ； `+` $<$ `/` ； `*` $>$ `+` ； `/` $>$ `+` 等。
  
  由规则 2，运算遵循左结合性，当两个运算符相同时，先出现的运算符优先级高，所以有 `+` $>$ `+` ； `_` $>$ `_` ； `*` $>$ `*` ； `/` $>$ `/` 。
  
  由规则 3，括号内的优先级高， `+` 、 `-` 、 `*` 和 `/` 为 $\theta _1$ 时的优先性均低于 `(` 但高于 `)` 。表中的 `(` $=$ `)` 表示当左右括号相遇时，括号内的运算已经完成。为了便于实现，假设每个表达式均以 `#` 开始，以 `#` 结束。所以 `#` $=$ `#` 表示整个表达式求值完毕。 `)` 与 `(` 、 `#` 与 `)` 以及 `(` 与 `#` 之间无优先关系，这是因为表达式中不允许它们相继出现一旦遇到这种情况，则可以认为出现了语法错误。在下面的讨论中，我们暂假定所输入的表达式不会出现语法错误。
  
  **【案例实现】**
  
  为实现算符优先算法，可以使用两个工作栈，一个称作 `OPTR` ，用以寄存运算符；另一个称作 `OPND` ，用以寄存操作数或运算结果。
  
  > ***算法：表达式求值***
  > 
  > **【算法步骤】**
  > 
  > 1. 初始化 `OPTR` 栈和 `OPND` 栈，将表达式起始符 `#` 压入 `OPTR` 栈。
  > 2. 扫描表达式，读入第一个字符 `ch` ，如果表达式没有扫描完毕至 `#` 或 `OPTR` 的栈顶元素不为 `#` 时，则循环执行以下操作：
  >    - 若 `ch` 不是运算符，则压入 `OPND` 栈，读人下一字符 `ch` ；
  >    - 若 `ch` 是运算符，则根据 `OPTR` 的栈顶元素和 `ch` 的优先级比较结果，做不同的处理：
  >      - 若是小于，则 `ch` 压入 `OPTR` 栈，读入下一字符 `ch` ；
  >      - 若是大于，则弹出 `OPTR` 栈顶的运算符，从 `OPND` 栈弹出两个数，进行相应运算，结果压入 `OPND` 栈；
  >      - 若是等于，则 `OPTR` 的栈顶元素是 `(` 且 `ch` 是 `)` ，这时弹出 `OPTR` 栈顶的 `(` ，相当于括号匹配成功，然后读入下一字符 `ch` 。
  > 3. `OPND` 栈顶元素即为表达式求值结果，返回此元素。
  > 
  > **【算法描述】**
  > 
  > ```cpp
  > char EvaluateExpression(void)
  > {   // 算术表达式求值的算符优先算法，设 OPTR 和 OPND 分别为运算符栈和操作数栈
  >     InitStack(OPND);                                // 初始化 OPND 栈
  >     Initstack(OPTR);                                // 初始化 OPTR 栈
  >     Push(OPTR, '#');                                // 将表达式起始符“#”压人 OPTR 栈
  >     cin >> ch;
  >     while (ch != '#' || GetTop(OPTR) != '#')        // 表达式没有扫描完毕或 OPTR 的栈顶元素不为“#”
  >     {
  >         if (!In(ch))
  >         {
  >             Push(OPND, ch);                         // ch 不是运算符则进 OPND 栈
  >             cin >> ch;
  >         }
  >         else
  >             switch (Precede(GetTop(OPTR), ch))      // 比较 OPTR 的栈顶元素和 ch 的优先级
  >             {
  >             case '<':
  >                 Push(OPTR, ch);
  >                 cin >> ch;
  >                 break;
  >             case '>':
  >                 Pop(OPTR, theta);                   // 弹出 OPTR 栈顶的运算符
  >                 Pop(OPND, b);
  >                 Pop(OPND, a);                       // 弹出 OPND 栈顶的两个运算数
  >                 Push(OPND, Operate(a, theta, b));   // 将运算结果压入 OPND 栈
  >                 break;
  >             case '=':                               // OPTR 的栈顶元素是“(”且 ch 是“)”
  >                 Pop(OPTR, x);
  >                 cin >> ch;                          // 弹出 OPTR 栈顶的“(”，读入下一字符 ch
  >                 break;
  >             } // switch
  >     } // while
  >     return GetTop(OPND);                            // OPND 栈顶元素即为表达式求值结果
  > }
  > ```
  > 
  > 算法调用的三个函数需要读者自行补充完成。其中函数 `In()` 是判定读入的字符 `ch` 是否为运算符， `Precede()` 是判定运算符栈的栈顶元素与读入的  运算符之间优先关系的函数， `Operate()` 为进行二元运算的函数。
  > 
  > 另外需要特别说明的是，上述算法中的操作数只能是一位数，因为这里使用的 `OPND栈` 是字符栈，如果要进行多位数的运算，则需要将 `OPND` 栈改为数  栈，读入的数字字符拼成数之后再入栈。读者可以改进此算法，使之能完成多位数的运算。
  > 
  > **【算法分析】**
  > 
  > 同 [*算法：括号的匹配*](#算法：括号的匹配) 一样，此算法从头到尾扫描表达式中每个字符，若表达式的字符串长度为 $n$ ，则此算法的时间复杂度为 $O(n)$ 。算法在运行时所占用的辅助空间主要取决于 `OPTR` 栈和 `OPND` 栈的大小，显然，它们的空间大小之和不会超过 $n$ ，所以此算法的空间复杂度也同样为 $O(n)$ 。
    
  **例 3.2 算法表达式的求值过程**
  
  利用上面的算法对算术表达式 $3*(7-2)$ 进行求值，给出其求值的具体过程。
  
  在表达式两端先增加 `#` ，改写为
  
  $$\#3*(7-2)\#$$
  
  具体操作过程如表所示。
  
  | 步骤 | `OPTR` 栈 | `OPND` 栈 |          读入字符          |               主要操作               |
  |:----:|:---------:|:---------:|:-------------------------:|:-------------------------------------|
  |   1  |    `#`    |           | `3*(7-2)#` <br> `^-------` | `Push(OPND, '3')`                    |
  |   2  |    `#`    |    `3`    |  `*(7-2)#` <br> `^------`  | `Push(OPTR, '*')`                    |
  |   3  |    `#*`   |    `3`    |   `(7-2)#` <br> `^-----`   | `Push(OPTR, '(')`                    |
  |   4  |   `#*(`   |    `3`    |    `7-2)#` <br> `^----`    | `Push(OPND, '7')`                    |
  |   5  |   `#*(`   |   `3 7`   |     `-2)#` <br> `^---`     | `Push(OPTR, '-')`                    |
  |   6  |   `#*(-`  |   `3 7`   |      `2)#` <br> `^--`      | `Push(OPND, '2')`                    |
  |   7  |   `#*(-`  |  `3 7 2`  |       `)#` <br> `^-`       | `Push(OPND, Operate('7', '-', '2'))` |
  |   8  |   `#*(`   |   `3 5`   |       `)#` <br> `^-`       | `Pop(OPTR) { 消去一对括号 }`         |
  |   9  |    `#*`   |   `3 5`   |        `#` <br> `^`        | `Push(OPND, Operate('3', '*', '5'))` |
  |  10  |    `#`    |    `15`   |        `#` <br> `^`        | `return(GetTop(OPND))`               |
  
  在高级语言的编译处理过程中，实际上不只是表达式求值可以借助栈来实现，高级语言中一般语法成分的分析都可以借助栈来实现，在编译原理后续课程中会涉及栈在语法、语义等分析算法中的应用。

<br>

- **案例 3.4：舞伴问题**
  
  **【案例分析】**
  
  对于舞伴配对问题，先入队的男士或女士先出队配成舞伴，因此设置两个队列分别存放男士和女士入队者。假设男士和女士的记录存放在一个数组中作为输入，然后依次扫描该数组的各元素，并根据性别来决定是进入男队还是女队。当这两个队列构造完成之后，依次将两队当前的队头元素出队来配成舞伴，直至某队列变空为止。此时，若某队仍有等待配对者，则输出此队列中排在队头的等待者的姓名，此人将是下一轮舞曲开始时第一个可获得舞伴的人。
  
  **【案例实现】**
  
  算法中有关数据结构的定义如下:
  
  ```cpp
  // -----跳舞者个人信息-----
  typedef struct {
      char name[20];          // 姓名
      char sex;               // 性别，'E'表示女性，'M'表示男性
  } Person;
  
  // -----队列的顺序存储结构-----
  #define MAXQSIZE 100        // 队列可能达到的最大长度
  typedef struct {
      Person * base;          // 队列中数据元素类型为 Person
      int front;              // 头指针
      int rear;               // 尾指针
  } SqQueue;
  SqQueue Mdancers, Fdancers; // 分别存放男士和女士入队者队列
  ```
  
  > ***算法：舞伴问题***
  > 
  > **【算法步骤】**
  > 
  > 1. 初始化 `Mdancers` 队列和 `Fdancers` 队列。
  > 2. 反复循环，依次将跳舞者根据其性别插入 `Mdancers` 队列或 `Fdancers `队列。
  > 3. 当 `Mdancers` 队列和 `Fdancers` 队列均为非空时，反复循环，依次输出男女舞伴的姓名。
  > 4. 如果 `Mdancers` 队列为空而 `Fdancers` 队列非空，则输出 `Fdancers` 队列的队头女士的姓名。
  > 5. 如果 `Fdancers` 队列为空而 `Mdancers` 队列非空，则输出 `Mdancers` 队列的队头男士的姓名。
  > 
  > **【算法描述】**
  > 
  > ```cpp
  > void DancePartner(Person dancer[], int num)
  > {   // 结构数组 dancer 中存放跳舞的男女，num 是跳舞的人数。
  >     InitQueue(Mdancers);            // 男士队列初始化
  >     InitQueue(Fdancers);            // 女士队列初始化
  >     for (i = 0; i < num; i++)       // 依次将跳舞者根据其性别入队
  >     {
  >         p = dancer[i];
  >         if (p.sex == 'F')
  >             EnQueue(Fdancers, p);   // 插入女队
  >         else
  >             EnQueue(Mdancers, p);   // 插入男队
  >     }
  >     cout << "The dancing partners are:\n";
  >     while (!QueueEmpty(Fdancers) && !QueueEmpty(Mdancers))
  >     {   // 依次输出男女舞伴的姓名
  >         DeQueue(Fdancers, p);       // 女士出队
  >         cout << p.name << " ";      // 输出出队女士姓名
  >         DeQueue(Mdancers, p);       // 男士出队
  >         cout << p.name << endl;     // 输出出队男士姓名
  >     }
  >     if (!QueueEmpty(Fdancers))      // 女士队列非空，输出队头女士的姓名
  >     {
  >         p = GetHead(Fdancers);      // 取女士队头
  >         cout << "The first woman to get a partner is: " << p.name << endl;
  >     }
  >     else if (!QueueEmpty(Mdancers)) // 男士队列非空，输出队头男士的姓名
  >     {
  >         p = GetHead(Mdancers);      // 取男士队头
  >         cout << "The first man to get a partner is: " << p.name << endl;
  >     }
  > }
  > ```
  > 
  > **【算法分析】**
  > 
  > 若跳舞者人数总计为 $n$ ，则此算法的时间复杂度为 $O(n)$ 。空间复杂度取决于 `Mdancers` 队列和 `Fdancers` 队列的长度，二者长度之和不会超过 $n$ ，因此空间复杂度也同样为 $O(n)$ 。

队列在程序设计中也有很多应用，凡是符合先进先出原则的数学模型，都可以用队列。最典型的例子是操作系统中用来解决主机与外设之间速度不匹配问题或多个用户引起的资源竞争问题。

例如，一个局域网上有一台共享的网络打印机，网上每个用户都可以将数据发送给网络打印机进行打印。为了保证能够正常打印，操作系统为网络打印机生成一个“作业队列”，每个申请打印的“作业”应按先后的顺序排队，打印机从作业队列中逐个提取作业进行打印。

这方面的例子很多，在操作系统等后续课程中会涉及大量队列这种数据结构的应用。

在实际应用中，队列应用的例子更是常见，通常用以模拟排队情景。例如，拿汽车加油站来说，通常的结构基本上是：入口和出口为单行道，加油车道可能有若干条。每辆车加油都要经过三段路程，第一段是在入口处排队等候进入加油车道；第二段是在加油车道排队等候加油；第三段是在进入出口处排队等候离开。实际上，这三段都是队列结构。若用算法模拟这个过程，总共需要设置的队列个数应该为加油车道数加上 2。