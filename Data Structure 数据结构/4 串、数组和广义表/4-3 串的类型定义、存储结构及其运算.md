# 4.3 串的类型定义、存储结构及其运算

## 4.3.1 串的抽象类型定义

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象。例如，在线性表中查找某个元素，求取某个元素，在某个位置上插入一个元素或删除一个元素等；而在串的基本操作中，通常以“串的整体”作为操作对象，例如，在串中查找某个子串，求取一个子串，在串的某个位置上插入一个子串，以及删除一个子串等。

> ***串的抽象数据类型的定义如下：***
> 
> **$ADT\ String$** {
> 
> &ensp;&ensp;&ensp;&ensp;**数据对象**： $D=\{a_i\ |\ a_i∈CharacterSet,\ i=1,2,...,n,\ n≥0\}$
> 
> &ensp;&ensp;&ensp;&ensp;**数据关系**： $R1=\{\langle a_{i-1},a_i\rangle\ |\ a_{i-1},a_i∈D,\ i=2,...,n\}$
> 
> &ensp;&ensp;&ensp;&ensp;**基本操作**：
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StrAssign(\&T,chars)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件： $chars$ 是字符串常量。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：生成一个其值等于 $chars$ 的串 $T$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StrCopy(\&T,S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：由串 $S$ 复制得串 $T$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StrEmpty(S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：若 $S$ 为空串，则返回 $true$ ，否则返回 $false$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StrCompare(S,T)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 和 $T$ 存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：若 $S>T$ ，则返回值 $>0$ ；若 $S=T$ ，则返回值 $=0$ ；若 $S<T$ ，则返回值 $<0$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StrLength(S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：返回 $S$ 的元素个数，称为串的长度。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $ClearString(\&S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：将 $S$ 清为空串。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $Concat(\&T,S1,S2)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S1$ 和 $S2$ 存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：用 $T$ 返回由 $S1$ 和 $S2$ 联接而成的新串。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $SubString(\&Sub,S,pos,len)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 存在， $1≤pos≤StrLength(S)$ 且 $0≤len≤StrLength(S)-pos+1$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：用 $Sub$ 返回串 $S$ 的第 $pos$ 个字符起长度为 $len$ 的子串。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $Index(S,T,pos)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 和 $T$ 存在， $T$ 是非空串， $1≤pos≤StrLength(S)$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：若主串 $S$ 中存在和串 $T$ 值相同的子串，则返回它在主串 $S$ 中第 $pos$ 个字符之后第一次出现的位置；否则函数值为 $0$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $Replace (\&S,T,V)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ ， $T$ 和 $V$ 存在， $T$ 是非空串。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：用 $V$ 替换主串 $S$ 中出现的所有与 $T$ 相等的不重叠的子串。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StrInsert (\&S,pos,T)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 和 $T$ 存在， $1≤pos≤StrLength(S)+1$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：在串 $S$ 的第 $pos$ 个字符之前插入串 $T$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StrDelete(\&S,pos,len)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 存在， $1≤pos≤StrLength(S)-len+1$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：从串 $S$ 中删除第 $pos$ 个字符起长度为 $len$ 的子串。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $DestroyString(\&S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：串 $S$ 存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：串 $S$ 被销毁。
> 
> } **$ADT\ String$**

对于串的基本操作集可以有不同的定义方法，读者在使用高级程序设计语言中的串类型时应以该语言的参考手册为准。


---


## 4.3.2 串的存储结构
与线性表类似，串也有两种基本存储结构：顺序存储和链式存储。但考虑到存储效率和算法的方便性，**串多采用顺序存储结构**。

<br>

### 串的顺序存储
类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：

```cpp
// -----串的定长顺序存储结构-----
#define MAXLEN 255          // 串的最大长度
typedef struct {
    char ch[MAXLEN + 1];    // 存储串的一维数组
    int length;             // 串的当前长度
} SString;
```

其中， `MAXLEN` 表示串的最大长度， `ch` 是存储字符串的一维数组，每个分量存储一个字符， `length` 表示字符串的当前长度。为了便于说明问题，本章后面算法描述当中所用到的顺序存储的字符串都是从下标为 `1` 的数组分量开始存储的，下标为 `0` 的分量闲置不用。

这种定义方式是静态的，在编译时刻就确定了串空间的大小。而多数情况下，串的操作是以串的整体形式参与的，串变量之间的长度相差较大，在操作中串值长度的变化也较大，这样为串变量设定固定大小的空间不尽合理。因此最好是根据实际需要，在程序执行过程中动态地分配和释放字符数组空间。在 C 语言中，存在一个称之为“堆”（Heap）的自由存储区，可以为每个新产生的串动态分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时为了以后处理方便，约定串长也作为存储结构的一部分。这种字符串的存储方式也称为**串的堆式顺序存储结构**，定义如下：

```cpp
//-----串的堆式顺序存储结构-----
typedef struct {
    char * ch;  // 若是非空串，则按串长分配存储区，否则 ch 为 NULL
    int length; // 串的当前长度
} HString;
```

<br>

### 串的链式存储
顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。例如，图 (a) 所示为结点大小为 $4$ （即每个结点存放 $4$ 个字符）的链表，图 (b) 所示为结点大小为 $1$ 的链表。当结点大小大于 $1$ 时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上 `#` 或其他的非串值字符（通常 `#` 不属于串的字符集，是一个特殊的符号）。

- 串值的链表存储方式：
  ![串值的链表存储方式](img/串值的链表存储方式.jpg "串值的链表存储方式")

为了便于进行串的操作，当以链表存储串值时，除头指针外，还可附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构，说明如下：

```cpp
// -----串的链式存储结构-----
#define CHUNKSIZE 80        // 可由用户定义的块大小
typedef struct Chunk {
    char ch[CHUNKSIZE];
    struct Chunk * next;
} Chunk;

typedef struct {
    Chunk * head, * tail;   // 串的头和尾指针
    int length;             // 串的当前长度
} LString;
```

在链式存储方式中，结点大小的选择直接影响着串处理的效率。在各种串的处理系统中，所处理的串往往很长或很多，如一本书的几百万个字符，情报资料的成千上万个条目，这就要求考虑串值的存储密度。

显然，存储密度小（如结点大小为 $1$ 时），运算处理方便，然而，存储占用量大。如果在串处理过程中需进行内、外存交换的话，则会因为内、外存交换操作过多而影响处理的总效率。应该看到，串的字符集的大小也是一个重要因素。一般来说，字符集小，则字符的机内编码就短，这也影响串值存储方式的选取。

串值的链式存储结构对某些串操作，如联接操作等，有一定方便之处，但总的说来，不如顺序存储结构灵活，它占用存储量大且操作复杂。此外，串值在链式存储结构时，串操作的实现和线性表在链表存储结构中的操作类似，故在此不作详细讨论。下面 4.3.3 小节的模式匹配算法是采用串的定长顺序存储结构实现的。


---


## 4.3.3 串的模式匹配算法
子串的定位运算通常称为串的**模式匹配**或**串匹配**。此运算的应用非常广泛，比如在搜索引擎、