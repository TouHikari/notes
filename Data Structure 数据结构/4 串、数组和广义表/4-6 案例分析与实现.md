# 案例分析与实现

- **案例 4.1：病毒感染检测**
  
  **【案例分析】**
  
  因为患者的 DNA 和病毒 DNA 均是由一些字母组成的字符串序列，要检测某种病毒 DNA 序列是否在患者的 DNA 序列中出现过，实际上就是字符串的模式匹配问题。可以利用 BF 算法，也可以利用更高效的 KMP 算法。但与一般的模式匹配问题不同的是，此案例中病毒的 DNA 序列是环状的，这样需要对传统的 BF 算法或 KMP 算法进行改进。
  
  下面给出利用 BF 算法实现检测的方案。
  
  **【案例实现】**
  
  对于每一个待检测的任务，假设病毒 DNA 序列的长度是 $m$ ，因为病毒 DNA 序列是环状的， 为了线性取到每个可行的长度为 $m$ 的模式串，可将存储病毒 DNA 序列的字符串长度扩大为 $2m$ ，将病毒 DNA 序列连续存储两次。然后循环 $m$ 次，依次取得每个长度为 $m$ 的环状字符串，将此字符串作为模式串，将人的 DNA 序列作为主串，调用 BF 算法进行模式匹配。只要匹配成功，即可中止循环，表明该人感染了对应的病毒；否则，循环 $m$ 次结束循环时，可通过 BF 算法的返回值判断该人是否感染了对应的病毒。
  
  > ***算法：病毒感染检测***
  > 
  > **【算法步骤】**
  > 
  > 1. 从文件中读取待检测的任务数 `num` 。
  > 2. 根据 `num` 个数依次检测每对病毒 DNA 和人的 DNA 是否匹配，循环 `num` 次，执行以下操作：
  >    - 从文件中分别读取一对病毒 DNA 序列和人的 DNA 序列；
  >    - 设置一个标志性变量 `flag` ，用来标识是否匹配成功，初始为 `0` ，表示未匹配；
  >    - 病毒 DNA 序列的长度是 $m$ ，将存储病毒 DNA 序列的字符串长度扩大为 $2m$ ，将病毒DNA序列连续存储两次；
  >    - 循环 $m$ 次，重复执行以下操作：
  >      - 依次取得每个长度为 $m$ 的病毒 DNA 环状字符串；
  >      - 将此字符串作为模式串，将人的 DNA 序列作为主串，调用 BF 算法进行模式匹配，将匹配结果返回赋值给 `flag` ;
  >      - 若 `flag` 非 `0` ，表示匹配成功，中止循环，表明该人感染了对应的病毒。
  >    - 退出循环时，判断 `flag` 的值，若 `flag` 非 `0` ，输出 `YES`，否则，输出 `NO` 。
  > 
  > **【算法描述】**
  > 
  > ```cpp
  > void Virus_detection()
  > {   // 利用 BF 算法实现病毒检测
  >     ifstream inFile("病毒感染检测输入数据.txt");
  >     ofstream outFile("病毒感染检测输出结果.txt");
  >     inFile >> num;                              // 读取待检测的任务数
  >     while (num--)                               // 依次检测每对病毒 DNA 和人的 DNA 是否匹配
  >     {
  >         inFile >> Virus.ch + 1;                 // 读取病毒 DNA 序列，字符串从下标 1 开始存放
  >         inFile >> Person.ch + 1;                // 读取人的 DNA 序列
  >         Vir = Virus.ch;                         // 将病毒 DNA 临时暂存在 Vir 中，以备输出
  >         flag = 0;                               // 用来标识是否匹配，初始为 0，匹配后为非 0
  >         m = Virus.length;                       // 病毒 DNA 序列的长度是 m
  >         for (i = m + 1, j = 1; j <= m; j++)
  >             Virus.ch[i++] = Virus.ch[j];        // 将病毒字符串的长度扩大 2 倍
  >         Virus.ch[2 * m + 1] = '\0';             // 添加结束符号
  >         for (i = 0; i < m; i++)                 // 依次取得每个长度为 m 的病毒 DNA 环状字符串 temp
  >         {
  >             for (j = 1; j <= m; j++)
  >                 temp.ch[j] = Virus.ch[i + j];
  >             temp.ch[m + 1] = '\0';              // 添加结束符号
  >             flag = Index_BF(Person, temp, 1);   // 模式匹配
  >             if (flag)
  >                 break;                          // 匹配即可退出循环
  >         } // for
  >         if (flag)
  >             outFile << Vir + 1 << "    " << Person.ch + 1 << " " << "YES" << endl;
  >         else
  >             outFile << Vir + 1 << "    " << Person.ch + 1 << " " << "NO" << endl;
  >     }
  > }
  > ```
  > 
  > **【算法分析】**
  > 
  > 对于每一个待检测的任务而言，该算法都需要执行 $m$ 次模式匹配，假设人的 DNA 序列长度为 $n$ ，由于 BF 算法的时间复杂度为 $O(m\times n)$ ，因此，对于每一个待检测的任务，时间复杂度都为 $O(m×m×n)$ 。如果待检测的任务个数为 $num$ ，则上述算法的时间复杂度为 $O(num×m×m×n)$ ，时间复杂度较高。利用 KMP 算法完成模式匹配将有效地提高匹配效率，读者可以模仿该算法，实现利用 KMP 算法完成检测的方案。
