# 1.6 数据结构与 C 语言表示

## 1.6.1 数据结构与程序设计的关联性
编写程序仅仅掌握语言是不够的，还必须掌握数据的组织、存储和运算方法。数据结构是在积累程序设计经验的基础上形成的，是提高程序设计能力的基础和关键所在。

> ***示例：求一名学生 10 次 C 语言程序设计的测试成绩总分与平均分。***
> *这 10 次测验的成绩分别为 80，85，77，56，68，83，90，92，80，98。*
>
> ```c
> // 示例 1
> int main()
> {
>     int sum, average;
>     int t1, t2, t3, t4, t5, t6, t7, t8, t9, t10; 
>     t1 = 80; t2 = 85; t3 = 77; t4 = 56; t5 = 68;
>     t6 = 83; t7 = 90; t8 = 92; t9 = 80; t10 = 98;
>     sum = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;
>     average = sum / 10;
>     printf("总分 = %d\n", sum);
>     printf("平均分 = %d\n", average);
> }
>```
> 如果要用该程序计算另一名学生的 10 次成绩就得修改程序，测验次数改变也要修改程序，程序扩充性与通用性较差。
>
> ```c
> // 示例 2
> int main()
> {
>     int sum, average;
>     int i;
>     int t[10] = { 80, 85, 77, 56, 68, 83, 90, 80, 98 };
>     sum = 0;
>     for (int i = 0; i < 10; i++)
>         sum = sum + t[i];
>     average = sum / 10;
>     printf("总分 = %d\n", sum);
>     printf("平均分 = %d\n", average);
> }
> ```
> 根据测试次数与测试成绩的关系，采用数组结构存储测验成绩，可以提高程序的适用范围。
>
> 分析以上两个程序，虽然都可以正确解决问题，但采用不同的方式存储成绩数据，产生了不同的程序设计方式。


---


## 1.6.2 结构化程序设计与函数的模块化
> Wirth 用“ **$算法 + 数据结构 = 程序$** ”阐释了程序设计的实质，也可以理解为程序是在数据的特定表示方式的基础上，对抽象算法的具体描述，即
>
> $$程序结构 = 控制结构 + 数据结构$$
>
> **结构化程序设计**是为使程序具有合理的结构，以保证程序正确性而规定的一套程序设计的方法。

<br>

### 结构化程序设计目的
通过设计结构良好的程序，**以程序良好的静态结构来保证程序动态执行的正确性**，使程序易理解、易调试、易维护，以提高软件开发的效率，减少出错率。

<br>

### 结构化程序设计的构成单元
任何程序都可由**顺序**、**选择**、**重复**三种基本控制结构来组成。

为灵活、方便地处理问题，程序语言中也可引入其他控制结构设施，如 goto 语句。限制 goto 语句的使用是很有必要的。

<br>

### 结构化程序设计方法
结构化程序设计的概念由 E. W. Dijkstra 于 1969 年提出，强调了从程序结构和风格上来研究程序设计问题。也将此方法称为“自顶而下”或“逐步求精”法。

1. **“自顶而下，逐步求精”。**

2. **“独立功能，一个入口，一个出口”的模块化结构。**

3. **“仅用三种基本控制结构”的设计原则。**


---


## 1.6.3 面向对象与抽象数据类型

<br>

### 面向对象的概念
Coad 和 Yourdon 给出面向对象的概念： **$面向对象 = 对象 + 类 + 继承 + 通信$** 。
- **对象**：是指在应用问题中出现的各种变体、事件和规格说明等，它是由一组属性和在这组值上的一组服务构成的，其中属性值确定了对象的状态。
- **类**：把具有相同属性和服务的对象归到了同一类，而把一个类中的每一个对象称为该类的一个实例，它们具有相同的服务。
- **继承**：面向对象方法的最有特色的方面。
- 各个类的对象间通过消息进行**通信**。

> **面向对象程序设计的特点是封装性（Encapsulation）、继承性（Inheritance）和多态性（Polymorphism）。**

定义在数据结构上的基本操作主要可列以下五种：
1. **插入**：在数据结构中的指定位置上增添新的数据元素。
2. **删除**：删除数据结构中某个指定的数据元素。
3. **更新**：改变数据结构中某个元素的值，在概念上等价于删除和插入操作的组合。
4. **查找**：在数据结构中寻找满足某个特定要求的数据元素（包括位置和值）。
5. **排序**：（在线性结构中）重新安排数据元素之间的逻辑顺序关系，使数据元素按值由小到大或由大到小的次序排列。

根据增、删、改、查找、排序等基本操作的特性，所有操作可以分为两大类：
- **加工型操作**，其操作的结果改变了结构的值；
- **引用型操作**，其操作的结果不改变结构的值。

> ***结构化的开发方法与面向对象的开发方法的不同之处：***
> - **结构化的开发方法是面向过程的开发方法，首先着眼于系统要实现的功能。从系统的输入、输出出发，分析系统要实现的功能，用自顶向下、逐步细化的方式建立系统的功能结构和相应的程序模块结构。** 一旦程序功能需要修改，就会涉及多个模块的修改。
> - **面向对象的开发方法首先着眼于应用问题所涉及的对象，包括对象、对象属性、要求的操作，从而建立对象结构和为解决问题需要执行的事件序列，据此建立类的继承层次结构，通过各个类的实例之间的消息连接实现所需的功能。** 如果系统功能的需求发生变化，只需修改类中的服务即可，此时类所代表的对象基本不变，从而确保系统不致因修改而退化。
>
> 与结构化的开发方法相比，采用面向对象开发方法的程序具有更高的可靠性、可修改性、可维护性、可复用性、可适用性和可理解性。

<br>

### 抽象数据类型与问题求解方法
抽象数据类型集中体现了**程序设计中一些最基本的原则：分解、抽象和信息隐藏**。对一个抽象数据类型，可以用代数系统形式严格地给予定义，而直观上可以把抽象数据类型看成是定义了一组运算的数学模型。

抽象数据类型的概念不仅包含数学模型，同时还包含这个模型上的运算。数据的逻辑结构和运算的定义组成了数据结构**规范**，而数据的存储结构和运算算法的描述构成了数据结构的**实现**。规范是实现的准则和依据，规范指明“做什么”，而实现解决“怎么做”。**一个抽象数据类型确定了一个模型，但将模型的实现细节隐藏起来；它定义了一组运算，但将运算的实现过程隐藏起来。**

> ***用抽象数据类型的概念来指导问题求解的过程：***
> |  **数学模型**  | **→** | **抽象数据类型** | **→** |  **数据结构**  |
> |:--------------:|:-----:|:----------------:|:-----:|:--------------:|
> | **非形式算法** | **→** |  **伪语言程序**  | **→** | **可执行程序** |
>
> 事实上，上表所说明的不仅是问题求解的一般过程，也是目前软件自动生成常用的模式。 $数学模型 → 抽象数据类型 → 数据结构$ ，恰好反映了信息结构转换的三个重要阶段，而在这个转换过程中，**数据结构是基础，抽象数据类型是中枢**。

<br>

### 抽象数据类型的实现途径
具体定义抽象数据类型需要借助于高级语言，对于抽象数据类型的具体实现则依赖于所选择的高级语言的功能。

1. **传统的面向过程的程序设计**
   如标准 Pascal、C 等面向过程的语言，这类语言利用抽象数据类型进行程序设计的基本方法是，只有嵌入了该类型说明和过程说明之后才可以访问该抽象数据类型，称之为数据结构受限的访问。

2. **“包”、“模型”的设计方法**
   这是面向对象模块结构的表示和实现。每个模块含有一个或多个抽象数据类型，不仅可以单独编译，而且为外部使用抽象数据类型提供了方便。比起第一种方法有了一定的进步。

3. **面向对象的程序设计（Object Oriented Programming, OOP）**
   借助对象描述抽象数据类型，存储结构的说明和操作函数的说明被封装在一个整体结构中，这个整体结构被称为“类”（Class），属于某个“类”的具体变量被称为“对象”（Object）。
   同一种数据类型和不同操作组将组成不同的数据类型，结构说明和过程说明被统一在一个整体对象之中，其中，数据结构的定义为对象的属性域，过程或函数定义在对象中，称为方法（Method），它是对对象的性能描述。

<br>

### 用 C 语言实现抽象数据类型
ADT 包括定义和实现两方面，其中定义是独立于实现的。定义仅给出一个 ADT 的逻辑特性，不必考虑如何在计算机中实现。

1. **ADT 的定义格式**
   例如：给出“简化线性表”的抽象数据类型的定义。

   > **$ADT\ Linear\_list$** {
   >
   > &ensp;&ensp;&ensp;&ensp;**数据元素**：所有 $a_i$ 属于统一数据对象， $i = 1, 2, \cdots , n$ ， $n ≥ 0$ ；
   >
   > &ensp;&ensp;&ensp;&ensp;**结构关系**：所有数据元素 $a_i(i = 1, 2, \cdots , n-1)$ 存在次序关系 $\langle a_i, a_{i+1} \rangle$ , $a_i$ 无前驱， $a_n$ 无后继。
   >
   > &ensp;&ensp;&ensp;&ensp;**基本操作**：设 $L$ 为 $Linear \_ List$ ，则有
   >
   > &ensp;&ensp;&ensp;&ensp; ① $InitList(L)$ ：初始化空线性表。
   >
   > &ensp;&ensp;&ensp;&ensp; ② $ListLength(L)$ ：求线性表的表长。
   >
   > &ensp;&ensp;&ensp;&ensp; ③ $GetData(L, i)$ ：取线性表的第 $i$ 个元素。
   >
   > &ensp;&ensp;&ensp;&ensp; ④ $InsList(L, i, b)$ ：在线性表第 $i$ 个位置插入元素 $b$ 。
   >
   > &ensp;&ensp;&ensp;&ensp; ⑤ $DelList(L, i)$ ：删除线性表的第 $i$ 个数据元素。
   >
   > } **$ADT\ Linear\_list$**

   在上述 ADT 中，数据元素所属的数据对象没有局限于一个具体的整型、实型或其他类型，所具有的操作也是抽象的数学特性，并没有具体到某一种计算机语言指令与程序编码。

2. **用 C 语言实现 ADT**
   主要包括以下两个方面：

    1. 通过结构体将 `int` 、 `float` 等基本数据类型组合到一起，构成一个结构体类型，再用 `typedef` 为该类型或该类型指针重新起一个名字，以增强程序的抽象性、简洁性和可读性。即采用 C 语言中 `typedef` 自定义类型来实现。
    2. 用 C 语言的子函数实现各个操作。

   > ***示例：用 C 语言实现复数 ADT 的实例。***
   > ```c
   > typedef struct {
   >     float realpart;
   >     float imagpart;
   > } Complex;
   > 
   > Complex create(float x, float y);
   > Complex add(Complex z1, Complex z2);
   > 
   > Complex create(float x, float y)
   > /* 利用 x, y 创建复数 z，并将 z 返回 */
   > {
   >     Complex z;
   >     z.realpart = x;
   >     z.imagpart = y;
   >     return z;
   > }
   > 
   > Complex add(Complex z1, Complex z2)
   > /* 求复数 z1, z2 的和 sum，并将 sum 返回 */
   > {
   >     Complex sum;
   >     sum.realpart = z1.realpart + z2.realpart;
   >     sum.imagpart = z1.imagpart + z2.imagpart;
   >     return sum;
   > }
   > 
   > int main(void)
   > {
   >     float a, b;
   >     Complex c1, c2, c3;
   > 
   >     printf("\n\n\n  Input realpart and imagpart: ");
   >     scanf("%f%f", &a, &b);
   >     c1 = create(a, b);
   > 
   >     printf("\n\n\n  Input realpart and imagpart: ");
   >     scanf("%f%f", &a, &b);
   >     c2 = create(a, b);
   > 
   >     c3 = add(c1, c2);
   >     printf("\n\n  c1 == %f + %fi", c1.realpart, c1.imagpart);
   >     printf("\n\n  c2 == %f + %fi", c2.realpart, c2.imagpart);
   >     printf("\n\n  c3 == c1 + c2 == %f + %fi", c3.realpart, c3.imagpart);
   >     
   >     return 0;
   > }
   > ```


---


## 1.6.4 算法描述规范与设计风格

<br>

### 算法表示格式与函数模块化

1. **算法表示形式**
   这里所有的算法都以如下所示的 C 函数形式表示，其中的结构类型可使用已有的定义。
   ```c
   [函数返回值类型] 函数名([形式参数及说明])
   {
       内部数据说明;
       执行语句组;
   } /*函数名*/
   ```

2. **函数模块化**
   一个完整的、可执行的 C 语言程序文件一般结构如下：
   ```c
   [包含文件语句]
   [宏定义语句]
   [自定义类型语句]
   [所有子函数的原型说明]
   [子函数 1 定义]
   ...
   [子函数 n 定义]
   [主函数定义]
   ```
   其中，每个函数具有独立功效，单看函数名与注释即可明白函数的功能，一旦需要修改某个函数，并不影响其他函数的运作，延伸下去就是**面向对象**的程序设计理念。

<br>

### 算法描述要点
C 语言存在语法规范上不严密的缺陷，在算法描述上应避免。

1. **加上必要的注释**
   注释形式可以采用 `/* 字符串 */` 的形式。对 C 语言程序中的任何部分需要时加上必要的注释，以提高程序的可读性。

2. **避免函数返回值隐含说明**
   对于主函数而言，返回类型和参数列表一般可以不写出，系统会执行一些默认的操作；
   对于子函数而言，返回类型是必不可少的。
   因为 C 语言规定**函数、参数、外部变量不加类型说明时则隐含为 `int` 类型**。
   **当编写的算法函数的函数值为 `int` 类型时必须用 `int` 显式说明，以避免类型失配或一直算法时出现错误；当函数返回值为空类型时必须用 `viod` 显式说明，以避免混淆。**

3. **预定义常量和类型**
   这里经常用到常量如 `TRUE` 、 `FALSE` 、 `Maxsize` 等可通过宏定义预定义为符号常量。
   ```c
   #define TRUE 1
   #define FALSE 0
   #define MAXSIZE 100
   #define OK 1
   #define ERROR 0
   ```

4. **使用有意义的函数名与变量名**
   见名达义，以增加程序的可读性。如用 `swap` 、 `max` 等变量名，一看就明白了函数的功能时交换与求最大值。而用 `Average` 、 `Sum` 、 `Count` 做变量名，无需看注释就已明确了这些变量的作用。

5. **避免可能出现的二义性表达**
   如表达式表示上，提倡使用 `i++` 或 `i = i + 1` ，不应使用 `i = ++i` ，因为后面的式子阅读困难，随编译器不同而异。

6. **规范多分支转向**
   在 C 语言中多分支 `switch` 语句中，每个 `case` 语句后都应使用 `break` 语句，使之规范到跳出此 `switch` 语句。

7. **简化输入、输出表述**
   输入输出函数中的类型部分不做严格要求，淡化表述。

8. **注意不同推出语句之间的区别**
    - `return <表达式>` 或 `return` ：用于函数结束。
    - `break` 语句：可用在循环语句或 `switch` 语句中结束循环或跳出情况语句。
    - `continue` 语句：可用在循环语句中结束本次循环过程，进入下一次循环过程。
    - `exit` 语句：表示出现异常情况时，控制退出用户程序。

<br>

### 与参数传递相关技术

1. **变量的作用域**
   在函数内定义的变量是**局部变量**，在函数外定义的变量是**外部变量**，又称**全局变量**或**全程变量**。

    - **全局变量：程序中所有函数都可以访问的量。**
    - **局部变量：只能在本函数中访问的量。**
      **变量作用域就是指包含该变量定义的最小范围。**

2. **参数传递方式**
   参数传递是函数之间进行信息通信的重要渠道，其参数传递的主要方式有**传值**和**传地址**两类。

   > ***函数参数表中的参数有两种：***
   > 第一种参数只为操作提供待处理数据，又称**值参**；
   > 第二种参数既能为操作提供待处理数据，又能返回操作结果，也称**变量参数**。

   不同语言的表示和实现方法不尽相同，如 ADT 中“返回结果的参数”，Pascal 语言用“变参”实现，C++ 语言通过“引用型参数”实现，而 C 语言用“指针参数”实现。

   C 语言调用函数时，实参代替形参的过程是一个单向的传值过程，在编译技术中称为值传递方式。C 语言中指针类型的参数传递可以看作是传地址方式。

   > ***示例：参数传递***
   > ```c
   > #include <stdio.h>
   > 
   > void swap1(int a, int b)
   > {
   >     int c;
   >     c = a;
   >     a = b;
   >     b = c;
   >     printf("swap1 中的 a = %d, b = %d, c = %d", a, b, c);
   > }
   > 
   > void swap2(int *a, int *b)
   > {
   >     int c;
   >     c = *a;
   >     *a = *b;
   >     *b = c;
   > }
   > 
   > void main(void)
   > {
   >     int x = 100, y = 800;
   >     swap1(x, y);
   >     printf("\n调用 swap1 后 x = %d, y = %d", x, y);
   >     x = 100;
   >     y = 800;
   >     swap2(&x, &y);
   >     printf("\n调用 swap2 后 x = %d, y = %d", x, y);
   > }
   > ```
   >
   > ***程序的输出结果为：***
   > ```c
   > swap1 中的 a = 800, b = 100
   > 调用 swap1 后 x = 100, y = 800
   > 调用 swap2 后 x = 800, y = 100
   > ```
   >
   > 调用 `swap1` 时，采用的是单项值传递。
   > 调用 `swap2` 时，采用的是地址传递。

<br>

### 函数结果的带出方式
函数结果共有**全程变量、函数返回值、传址函数**三种带出方式。

若函数结果需要带出多个值，该怎样实现？可以采用全局变量方式带出或通过地址传递方式（数组方式、结构体方式、指针方式）带出来实现。
1. **全局变量方式**
2. **数组方式**：如果要返回的是多个相同类型的值，可以将这些值放到一个结构体中，然后返回数组的指针或首地址。
3. **结构体方式**：如果要返回的是多个不同类型的值，可以将这些值放到一个结构体中，然后返回结构体的指针或全局变量。应注意的是该结构体必须是在全局范围内定义的结构体。
4. **指针方式**

> ***示例：函数带出方式***
> ```c
> #include <stdio.h>
> #include <stdlib.h>
> 
> typedef struct {
>     int max, min;
> } Data;
> 
> int MIN;    /* 全局变量 */
> 
> int fun1(int a[], int n)
> /* 通过函数 return 返回最大值，通过全局变量 MIN 带回最小值 */
> {
>     int i, max;
>     max = MIN = a[0];   // 给最大值、最小值赋初值
>     for (i = 1; i < n; i++)
>     {
>         if (a[i] > max)
>             max = a[i];
>         if (a[i] < MIN)
>             MIN = a[i];
>     }
>     return max;
> }
> 
> int *fun2(int a[], int n)
> /* 将最大值、最小值放到数组 b 中，通过 return 返回 */
> {
>     static int b[2];
>     b[0] = b[1] = a[0]; // 给最大值、最小值赋初值
>     int i;
>     for (i = 1; i < n; i++)
>     {
>         if (a[i] > b[0])
>             b[0] = a[i];
>         if (a[i] < b[1])
>             b[1] = a[i];
>     }
>     return b;
> }
> 
> Data * fun3(int a[], int n)
> /* 将最大值、最小值放到结构体中，通过 return 返回结构体指针 */
> {
>     Data * p;
>     int i;
>     p = (Data *)malloc(sizeof(Data));   // 指针初始化
>     p->max = p->min = a[0];             // 给最大值、最小值赋初值
>     for (i = 1; i < n; i++)
>     {
>         if (a[i] > p->max)
>             p->max = a[i];
>         if (a[i] < p->min)
>             p->min = a[i];
>     }
>     return p;
> }
> 
> Data fun4(int a[], int n)
> /* 将最大值、最小值放到结构体 p 中，通过结构体 p 带回返回值 */
> {
>     Data p;
>     int i;
>     p.max = p.min = a[0];   // 给最大值、最小值赋初值
>     for (i = 1; i < n; i++)
>     {
>         if (a[i] > p.max)
>             p.max = a[i];
>         if (a[i] < p.min)
>             p.min = a[i];
>     }
>     return p;
> }
> 
> void fun5(int a[], int n, int *p, int *q)
> /* 用指针带回结果，指针 p 指向最大值，指针 q 指向最小值 */
> {
>     int i;
>     *p = *q = a[0]; // 给最大值、最小值赋初值
>     for (i = 1; i < n; i++)
>     {
>         if (*p < a[i])
>             *p = a[i];
>         if (*q > a[i])
>             *q = a[i];
>     }
> }
> 
> void main(void)
> {
>     int a[10] = { 1, 3, 9, 8, 4, 2, 5, 0, 7, 6 }, max, *p;
>     Data * q;
>     Data z;
>     int x, y;
> 
>     max = fun1(a, 10);
>     printf("max = %d    min = %d\n", max, MIN);
> 
>     p = fun2(a, 10);
>     printf("max = %d    min = %d\n", p[0], p[1]);
> 
>     q = fun3(a, 10);
>     printf("max = %d    min = %d\n", q->max, q->min);
> 
>     z = fun4(a, 10);
>     printf("max = %d    min = %d\n", z.max, z.min);
> 
>     fun5(a, 10, &x, &y);
>     printf("max = %d    min = %d\n", x, y);
> }
> ```
