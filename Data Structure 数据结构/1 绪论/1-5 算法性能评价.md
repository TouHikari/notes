# 1.5 算法性能评价

## 1.5.1 算法的时间性能分析

<br>

### 算法耗费的时间
一个算法的执行时间是指算法中所有语句执行时间的总和。每条语句的执行时间等于该条语句的执行次数乘以执行一次所需的实际时间。

<br>

### 语句频度
语句频度是指**该语句在一个算法中重复执行的次数。**
一个算法的时间耗费就是该算法中所有语句频度之和。

> ***示例：求两个 n 阶方阵的乘积 `C = A × B`***
> ```c
> #define n 100
> void MatrixMulti(int a[n][n], int b[n][n], int c[n][n])
> {
>     for (int i = 0; i < n; i++)           // n + 1
>         for (int j = 0; j < n; j++)       // n * (n + 1)
>         {
>             c[i][j] = 0;                  // n * n
>             for (int k = 0; k < n; k++)   // n * n * (n + 1)
>                 c[i][j] = c[i][j] + a[i][k] * b[k][j]; // n * n * n
>         }
> }
> ```
> 在每一个语句后面都标示出了其语句频度。
> 该算法中**所有语句的频度之和**（即**算法的时间耗费**）为：
>
> $$f(n) = 2n^3 + 3n^2 + 2n + 1$$

<br>

### 算法的时间复杂度
为便于比较同一问题的不同算法，通常以算法中**基本操作重复执行的频度**作为度量标准。

算法的时间复杂度 $T(n)$ 是该算法的时间度量，记作

$$T(n) = O(f(n))$$

它表示随问题规模 $n$ 的增大，算法的执行时间的增长率和 $F(n)$ 的增长率相同，称作算法的渐近时间复杂度，简称**时间复杂度**。

在上面的算法 `MatrixMulti` 中，由于 $f(n)$ 和 $n^3$ 同阶，或者说数量级相同，因此 $O(n^3)$ 是算法 `MatrixMulti` 的渐近时间复杂度。

<br>

### 渐近时间复杂度
主要用算法**时间复杂度的数量级**（即算法的**渐近时间复杂度**）来评价一个算法的**时间性能**。

<br>

### 常用算法时间复杂度
数据结构中常用的时间复杂度频率计数有以下 7 种：
- 常数型： $O(1)$
- 线性型： $O(n)$
- 平方型： $O(n^2)$
- 立方型： $O(n^3)$
- 指数型： $O(2^n)$
- 对数型： $O(log_2n)$
- 二维型： $O(nlog_2n)$

> 一般来说，前三种可实现，后三种虽理论上可实现，但实际上只有当 $n$ 限制在很小的范围内时才有意义。

> 一般情况下，**随 $n$ 的增大， $T(n)$ 的增长较慢的算法为最优算法**，因此应该选择使用多项式阶 $O(n^2)$ 的算法，而避免使用指数阶的算法。

<br>

### 最坏时间复杂度和平均时间复杂度
算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。
> ***示例：在数值 `A[n]` 中查找给定值 `k` 的算法***
> ```c
> i = n - 1;
> while (i >= 0 && (A[i] != k ))
>     i--;  // 语句 (3)
> return i;
> ```
> 此算法中，`语句 (3)` 的频度不仅**与问题规模 `n` 有关**，还**与 `A` 的各元素值及 `k` 的取值有关**。
> - **最坏情况**：`A` 中没有与 `k` 相等的元素，则 `语句 (3)` 的频度 **$f(n) = n$**。
> - **最好情况**：`A` 中最后一个元素等于 `k`，则 `语句 (3)` 的频度 **$f(n)$** 是**常数 $0$**。


---


## 1.5.2 算法的空间性能分析

<br>

### 算法耗费的空间
一个算法的占用空间是指算法实际占用的辅助空间总和。
算法空间分析度量的标准并不是计算实际占用空间，而是计算整个算法的**辅助空间单元个数**。

<br>

### 算法的空间复杂度
算法的空间复杂度 $S(n)$ 定义为该算法所耗费的存储空间的数量级，它是问题规模 $n$ 的函数，记作

$$S(n) = O(f(n))$$

若算法执行时所需要的辅助空间相对于数据量而言是一个常数，则称这个算法为原地工作，辅助空间为 $O(1)$ 。

> ***示例：将一维数组 `a` 中的 `n` 个数据逆序存放到原数组中***
> ```c
> // 算法 1
> for (i = 0; i < n; i++)
>     b[i] = a[n - i - 1];
> for (i = 0; i < n; i++)
>     a[i] = b[i];
> ```
> ```c
> // 算法 2
> for (i = 0; i < n / 2; i++)
> {
>     t = a[i];
>     a[i] = a[n - i -1];
>     a[n - i - 1] = t;
> }
> ```
> `算法 1` 的空间复杂度为 **$O(n)$** ，需要**一个大小为 `n` 的辅助数组 `b`**。
> `算法 2` 的空间复杂度为 **$O(1)$** ， 仅需要**一个变量 `t`**，**与问题规模没有关系**。

**算法的时间复杂度和空间复杂度合称为算法的复杂度。**


---


## 1.5.3 算法性能选择
要想使一个算法既占用存储空间少，又运行时间短，而且其他性能也好，这是很难做到的。
只能根据具体情况进行取舍：
1. 若该程序**使用次数较少**，则**力求算法简明易懂**。
2. 对于**反复使用的程序**，应**尽可能选用快速的算法**。
3. 若**待解决的问题数据量极大，计算机的存储空间极小**，则相应算法**主要考虑如何节省空间**。
