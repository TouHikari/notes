# 遍历二叉树和线索二叉树
在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者是对树中的全部结点逐一进行处理，这就提出了一个遍历二叉树的问题。线索二叉树是在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树。

## 5.5.1 遍历二叉树

<br>

### 遍历二叉树算法描述

**遍历二叉树**（traversing binary tree）是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。访间的含义很广，可以是对结点做各种处理，包括输出结点的信息，对结点进行运算和修改等。遍历二又树是二叉树最基本的操作，也是二叉树其他各种操作的基础，遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列。由于二叉树的每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。

回顾二叉树的递归定义可知，二叉树是由 3 个基本单元组成：根结点、左子树和右子树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。假如从 $L$ 、 $D$ 、 $R$ 分别表示遍历左子树、访问根结点和遍历右子树，则可有 $DLR$ 、 $LDR$ 、 $LRD$ 、 $DRL$ 、 $RDL$ 、 $RLD$ 这 6 种遍历二叉树的方案。若限定先左后右，则只有前 3 种情况，分别称之为先（根）序遍历、中（根）序遍历和后（根）序遍历。基于二叉树的递归定义，可得下述遍历二叉树的递归算法定义。

***先序遍历二叉树的操作定义如下：***
若二叉树为空，则空操作；否则
1. 访问根结点；
2. 先序遍历左子树；
3. 先序遍历右子树。

***中序遍历二叉树的操作定义如下：***
若二叉树为空，则空操作；否则
1. 中序遍历左子树；
2. 访问根结点；
3. 中序遍历右子树。

***后序遍历二叉树的操作定义如下：***
若二叉树为空，则空操作；否则
1. 后序遍历左子树；
2. 后序遍历右子树；
3. 访问根结点。

- 表达式 `(a + b * (c - d) - e / f)` 的二叉树：
![表达式(a+b*(c-d)-e/f)的二叉树](https://static.owo.cab/notes/image/cs/ds/chapter05/表达式的二叉树.webp "表达式(a+b*(c-d)-e/f)的二叉树")

例如，上图所示的二叉树表示下述表达式

$$a+b*(c-d)-e/f$$

若先序遍历此二叉树，按访问结点的先后次序将结点排列起来，可得到二叉树的先序序列为

$$-+a*b-cd/ef$$

类似地，中序遍历此二叉树，可得此二叉树的中序序列为

$$a+b*c-d-e/f$$

后序遍历此二叉树，可得此二叉树的后序序列为

$$abcd-*+ef/-$$

从表达式来看，以上 3 个序列恰好为表达式的前缀表示（波兰式）、中缀表示和后缀表示（逆波兰式）。

下面的算法给出了中序遍历二叉树基本操作的递归算法在二叉链表上的实现，算法将结点的访问简化成数据的输出。

> ***算法：中序遍历的递归算法***
> 
> **【算法描述】**
> 
> ```cpp
> void InOrderTraverse(BiTree T)
> {   // 中序遍历二叉树 T 的递归算法
>     if (T)                          // 若二叉树非空
>     {
>         InOrderTraverse(T->lchild); // 中序遍历左子树
>         cout << T->data;            // 访问根结点
>         InOrderTraverse(T->rchild)；// 中序遍历右子树
>     }
> }
> ```
> 
> 只要改变输出语句的顺序，便可类似地实现先序遍历和后序遍历的递归算法，此处不再一一列举。

从上述二叉树遍历的定义可知，3 种遍历算法不同处仅在于访问根结点和遍历左、右子树的先后关系。如果在算法中暂且抹去和递归无关的 `cout` 语句，则 3 个遍历算法完全相同。由此，从递归执行过程的角度来看先序、中序和后序遍历也是完全相同的。下图 (b) 中用带箭头的虚线表示了这 3 种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历二叉树过程中访问结点时输出的信息。例如，由于中序遍历中访问结点是在遍历左子树之后、遍历右子树之前进行，则带圆形的字符标在向左递归返回和向右递归调用之间。由此，只要沿虚线从 $1$ 出发到 $2$ 结束，将沿途所见的三角形（或圆形、或方形）内的字符记下，便得到遍历二叉树的先序（或中序、或后序）序列。例如，从下图 (b) 分别可得下图 (a) 所示表达式的前缀表示（ $-*abc$ ）、中缀表示（ $a*b-c$ ）和后缀表示（ $ab*c-$ ）。

- <spam id="3种遍历过程示意图">3 种遍历过程示意图：</spam>
  ![3种遍历过程示意图](https://static.owo.cab/notes/image/cs/ds/chapter05/3种遍历过程示意图.webp "3种遍历过程示意图")

根据前面 3.4.4 小节的内容，可利用栈将递归算法改写成非递归算法，如下算法所示。例如，从中序遍历递归算法执行过程中递归工作栈的状态可见：
1. 工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针，则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈；
2. 若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层（即栈顶记录）中指针所指的根结点；
3. 若是从右子树返回，则表明当前层的遍历结束，应继续退栈。从另一个角度看，这意味着遍历右子树时不再需要保存当前层的根指针，直接修改栈顶记录中的指针即可。

> ***算法：中序遍历的非递归算法***
> 
> **【算法步骤】**
> 
> 1. 初始化一个空栈 `S`，指针 `p` 指向根结点。
> 2. 申请一个结点空间 `q` ，用来存放栈顶弹出的元素。
> 3. 当 `p` 非空或者栈 `S` 非空时，循环执行以下操作：
>    - 如果 `p` 非空，则将 `p` 进栈， `p` 指向该结点的左孩子；
>    - 如果 `p` 为空，则弹出栈顶元素并访问，将 `p` 指向该结点的右孩子。
> 
> **【算法描述】**
> 
> ```cpp
> void InorderTraverse(BiTree T)
> {   // 中序遍历二叉树 T 的非递归算法
>     InitStack(S);
>     p = T;
>     q = new BiTNode;
>     while (p || !StackEmpty(S))
>     {
>         if (p)                  // p 非空
>         {
>             Push(S, p);         // 根指针进栈
>             p = p->lchild;      // 根指针进栈，遍历左子树
>         }
>         else                    // p 为空
>         {
>             Pop(S, q);          // 退栈
>             cout << q->data;    // 访问根结点
>             p = q->rchild;      // 遍历右子树
>         }
>     } // while
> }
> ```
> 
> 按上述算法，[*上图 (a)*](#3种遍历过程示意图) 所示的二叉树的中序非递归遍历的栈 `S` 的变化过程如下图所示。
> 
> - 非递归中序遍历时栈 `S` 的变化情况：
>   ![非递归中序遍历时栈S的变化情况](https://static.owo.cab/notes/image/cs/ds/chapter05/非递归中序遍历时栈S的变化情况.webp "非递归中序遍历时栈S的变化情况")
> 
> **【算法分析】**
> 
> 无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含 $n$ 个结点的二叉树，其时间复杂度均为 $O(n)$  。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为 $n$ ，则空间复杂度也为 $O(n)$ 。二叉树的先序、中序和后序遍历是最常用的三种遍历方式。此外，还有一种按层次遍历二叉树的方式，这种方式按照“从上到下，从左到右”的顺序遍历二叉树，即先遍历二叉树第一层的结点，然后是第二层的结点，直到最底层的结点，对每一层的遍历按照从左到右的次序进行。例如，[*上图 (a)*](#3种遍历过程示意图) 所示的二叉树的层次遍历序列是 $-*cab$ 。层次遍历不是一个递归过程，层次遍历算法的实现可以借助队列这种数据结构，这里不做详细讨论。

<br>

### 根据遍历序列确定二叉树
从前面讨论的二叉树的遍历知道，若二叉树中各结点的值均不相同，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的。反过来，若已知二叉树遍历的任意两种序列，能否确定这棵二叉树呢？这样确定的二叉树是否是唯一的呢？

由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。根据定义，二叉树的先序遍历是先访问根结点，其次再按先序遍历方式遍历根结点的左子树，最后按先序遍历方式遍历根结点的右子树。这就是说，在先序序列中，第一个结点一定是二叉树的根结点。另一方面，中序遍历是先遍历左子树，然后访问根结点，最后再遍历右子树。这样，根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。这样，就确定了二叉树的三个结点。同时，左子树和右子树的根结点又可以分别把左子序列和右子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵二叉树。

同理，由二叉树的后序序列和中序序列也可唯一地确定一棵二叉树。因为，依据后序遍历和中序遍历的定义，后序序列的最后一个结点，就如同先序序列的第一个结点一样，可将中序序列分成两个子序列，分别为这个结点左子树的中序序列和右子树的中序序列，再拿出后序序列的倒数第二个结点，并继续分割中序序列，如此递归下去，当倒着取尽后序序列中的结点时，便可以得到一棵二叉树。

**例5.1** 已知一棵二叉树的中序序列和后序序列分别是 $BDCEAFHG$ 和 $DECBHGFA$ ，请画出这棵二叉树。

1. 由后序遍历特征，根结点必在后序序列尾部，即根结点是 $A$ ；
2. 由中序遍历特征，根结点必在其中间，而且其左部必全部是左子树子孙（ $BDCE$ ），其右
部必全部是右子树子孙（ $FHG$ ）；
3. 继而，根据后序中的 $DECB$ 子树可确定 $B$ 为 $A$ 的左孩子，根据 $HGF$ 子串可确定 $F$ 为 $A$ 的右孩子；依此类推，可以唯一地确定一棵二叉树，如图所示。

- 由中序序列和后序序列确定的二叉树：
  ![由中序序列和后序序列确定的二叉树](https://static.owo.cab/notes/image/cs/ds/chapter05/由中序序列和后序序列确定的二叉树.webp "由中序序列和后序序列确定的二叉树")

但是，由一棵二叉树的先序序列和后序序列不能唯一确定一棵二叉树，因为无法确定左右子树两部分。例如，如果有先序序列 $AB$ ，后序序列 $BA$ ，因为无法确定 $B$ 为左子树还是右子树，所以可得到如图所示的两棵不同的二叉树。

- 两颗不同的二叉树：
  ![两颗不同的二叉树](https://static.owo.cab/notes/image/cs/ds/chapter05/两颗不同的二叉树.webp "两颗不同的二叉树")

<br>

### 二叉树遍历算法的应用
“遍历”是二叉树各种操作的基础，假设访问结点的具体操作不仅仅局限于输出结点数据域的值，而把“访问”延伸到对结点的判别、计数等其他操作，可以解决一些关于二叉树的其他实际问题。如果在遍历过程中生成结点，这样便可建立二叉树的存储结构。

1. **创建二叉树的存储结构——二叉链表**
   
   为简化问题，设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表， `T` 为指向根结点的指针，对于给定的一个字符序列，依次读入字符，从根结点开始，递归创建二叉树。
      
   > ***算法：先序遍历的顺序建立二叉链表***
   > 
   > **【算法步骤】**
   > 
   > 1. 扫描字符序列，读入字符 `ch` 。
   > 2. 如果 `ch` 是一个 `#` 字符，则表明该二叉树为空树，即 `T` 为 `NULL` ；否则执行以下操作：
   >    - 申请一个结点空间 `T` ；
   >    - 将 `ch` 赋给 `T->data` ；
   >    - 递归创建 `T` 的左子树；
   >    - 递归创建 `T` 的右子树。
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > void CreateBiTree(BiTree &T)
   > {   // 按先序次序输人二叉树中结点的值（一个字符)，创建二叉链表表示的二叉树 T
   >     cin >> ch;
   >     if (ch == '#')
   >         T = NULL;                   // 递归结束，建空树
   >     else                            // 递归创建二叉树
   >     {
   >         T = new BiTNode;            // 生成根结点
   >         T->data = ch;               // 根结点数据城置为 ch
   >         CreateBiTree(T->lchild);    // 送归创建左子树
   >         CreateBiTree(T->rchild);    // 递归创建右子树
   >     } // else
   > }
   > ```
   
   - 链表存储结构：
     ![链表存储结构](https://static.owo.cab/notes/image/cs/ds/chapter05/链表存储结构.webp "链表存储结构")
   
   例如，对上图 (b) 所示的二叉树，读入字符的顺序为： `ABC#DE#G##F###` （其中 `#` 表示空树），可建立相应的二叉链表。

<br>

2. **复制二叉树**
   
   复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉树的特点，复制步骤如下：若二叉树不空，则首先复制根结点，这相当于二叉树先序遍历算法中访问根结点的语句；然后分别复制二叉树根结点的左子树和右子树，这相当于先序遍历中递归遍历左子树和右子树的语句。因此，复制函数的实现与二叉树先序遍历的实现非常类似。
   
   > ***算法：复制二叉树***
   > 
   > **【算法步骤】**
   > 
   > 如果是空树，递归结束，否则执行以下操作：
   > - 申请一个新结点空间，复制根结点；
   > - 递归复制左子树；
   > - 递归复制右子树。
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > void Copy(BiTree T, BiTree &NewT)
   > {   // 复制一棵和T完全相同的二叉树
   >     if (T == NULL)                      // 如果是空树，递归结束
   >     {
   >         NewT = NULL;
   >         return;
   >     }
   >     else
   >     {
   >         NewT = new BiTNode;
   >         NewT->data = T->data;           // 复制根结点
   >         copy(T->lchild, NewT->lchild);  // 递归复制左子树
   >         Copy(T->rchild, NewT->rchild);  // 递归复制右子树
   >     } // else
   > }
   > ```

<br>

3. **计算二叉树的深度**
   
   二叉树的深度为树中结点的最大层次，二叉树的深度为左右子树深度的较大者加 1。
   
   > ***算法：计算二叉树的深度***
   > 
   > **【算法步骤】**
   > 
   > 如果是空树，递归结束，深度为 0，否则执行以下操作：
   > - 递归计算左子树的深度记为 `m` ；
   > - 递归计算右子树的深度记为 `n` ；
   > - 如果 `m` 大于 `n` ，二叉树的深度为 `m + 1` ，否则为 `n + 1` 。
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > int Depth(BiTree T)
   > {   // 计算二叉树 T 的深度
   >     if (T == NULL)
   >         return 0;               // 如果是空树，深度为 0，递归结束
   >     else
   >     {
   >         m = Depth(T->lchild);   // 递归计算左子树的深度记为 m
   >         n = Depth(T->rchild);   // 递归计算右子树的深度记为 n
   >         if (m > n)              // 二叉树的深度为 m 与 n 的较大者加 1
   >             return (m + 1);
   >         else
   >             return (n + 1);
   >     }
   > }
   > ```
   
   显然，计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。

<br>

4. **统计二叉树中结点的个数**
   
   如果是空树，则结点个数为 0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上 1。
   
   > ***算法：统计二叉树中结点的个数***
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > int NodeCount(BiTree T)
   > {   // 统计二叉树 T 中结点的个数
   >     if (T == NULL)  // 如果是空树，则结点个数为 0，递归结束
   >         return 0;
   >     else            // 否则结点个数为左子树的结点个数 + 右子树的结点个数 + 1
   >         return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;
   > }
   > ```
   
   读者可以模仿此算法，写出以下算法：统计二叉树中叶结点（度为 0）的个数，度为 1 的结点个数和度为 2 的结点个数。算法实现的关键是如何表示度为 0、度为 1 或度为 2 的结点。


---


## 5.5.2 线索二叉树
1.线索二叉树的基本概念
遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序
序列、中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作，使每个结点（除第
一个和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继（在不至于混淆的情况，
后续描述中省去“直接”二字)。例如在图5.5所示的二又树结点的中序序列a+b*cd-e/f中，“”
的前驱是“*”，后继是“”。
但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得
到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到，为此
引入线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。
虽然可以在每个结点中增加两个指针域来存放在遍历时得到的有关前驱和后继信息，但这样
做使得结构的存储密度大大降低。由于有n个结点的二叉链表中必定存在n+1个空链域，因此
可以充分利用这些空链域来存放结点的前驱和后继信息。
试做如下规定：若结点有左子树，则其Ichild域指示其左孩子，否则令lchild域指示其前驱；
若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。为了避免混淆，尚
需改变结点结构，增加两个标志域，其结点形式如图5.15所示。