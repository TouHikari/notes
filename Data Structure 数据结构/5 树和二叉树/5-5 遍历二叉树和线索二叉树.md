# 遍历二叉树和线索二叉树
在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者是对树中的全部结点逐一进行处理，这就提出了一个遍历二叉树的问题。线索二叉树是在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树。

## 5.5.1 遍历二叉树

<br>

### 遍历二叉树算法描述

**遍历二叉树**（traversing binary tree）是指按某条搜索路径巡访树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。访间的含义很广，可以是对结点做各种处理，包括输出结点的信息，对结点进行运算和修改等。遍历二又树是二叉树最基本的操作，也是二叉树其他各种操作的基础，遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列。由于二叉树的每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。

回顾二叉树的递归定义可知，二叉树是由 3 个基本单元组成：根结点、左子树和右子树。因此，若能依次遍历这三部分，便是遍历了整个二叉树。假如从 $L$ 、 $D$ 、 $R$ 分别表示遍历左子树、访问根结点和遍历右子树，则可有 $DLR$ 、 $LDR$ 、 $LRD$ 、 $DRL$ 、 $RDL$ 、 $RLD$ 这 6 种遍历二叉树的方案。若限定先左后右，则只有前 3 种情况，分别称之为先（根）序遍历、中（根）序遍历和后（根）序遍历。基于二叉树的递归定义，可得下述遍历二叉树的递归算法定义。

***先序遍历二叉树的操作定义如下：***
若二叉树为空，则空操作；否则
1. 访问根结点；
2. 先序遍历左子树；
3. 先序遍历右子树。

***中序遍历二叉树的操作定义如下：***
若二叉树为空，则空操作；否则
1. 中序遍历左子树；
2. 访问根结点；
3. 中序遍历右子树。

***后序遍历二叉树的操作定义如下：***
若二叉树为空，则空操作；否则
1. 后序遍历左子树；
2. 后序遍历右子树；
3. 访问根结点。

- <spam id="表达式(a+b*(c-d)-e/f)的二叉树">表达式 `(a + b * (c - d) - e / f)` 的二叉树</spam>：
![表达式(a+b*(c-d)-e/f)的二叉树](https://static.owo.cab/notes/image/cs/ds/chapter05/表达式的二叉树.webp "表达式(a+b*(c-d)-e/f)的二叉树")

例如，上图所示的二叉树表示下述表达式

$$a+b*(c-d)-e/f$$

若先序遍历此二叉树，按访问结点的先后次序将结点排列起来，可得到二叉树的先序序列为

$$-+a*b-cd/ef$$

类似地，中序遍历此二叉树，可得此二叉树的中序序列为

$$a+b*c-d-e/f$$

后序遍历此二叉树，可得此二叉树的后序序列为

$$abcd-*+ef/-$$

从表达式来看，以上 3 个序列恰好为表达式的前缀表示（波兰式）、中缀表示和后缀表示（逆波兰式）。

下面的算法给出了中序遍历二叉树基本操作的递归算法在二叉链表上的实现，算法将结点的访问简化成数据的输出。

> ***算法：中序遍历的递归算法***
> 
> **【算法描述】**
> 
> ```cpp
> void InOrderTraverse(BiTree T)
> {   // 中序遍历二叉树 T 的递归算法
>     if (T)                          // 若二叉树非空
>     {
>         InOrderTraverse(T->lchild); // 中序遍历左子树
>         cout << T->data;            // 访问根结点
>         InOrderTraverse(T->rchild)；// 中序遍历右子树
>     }
> }
> ```
> 
> 只要改变输出语句的顺序，便可类似地实现先序遍历和后序遍历的递归算法，此处不再一一列举。

从上述二叉树遍历的定义可知，3 种遍历算法不同处仅在于访问根结点和遍历左、右子树的先后关系。如果在算法中暂且抹去和递归无关的 `cout` 语句，则 3 个遍历算法完全相同。由此，从递归执行过程的角度来看先序、中序和后序遍历也是完全相同的。下图 (b) 中用带箭头的虚线表示了这 3 种遍历算法的递归执行过程。其中，向下的箭头表示更深一层的递归调用，向上的箭头表示从递归调用退出返回；虚线旁三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历二叉树过程中访问结点时输出的信息。例如，由于中序遍历中访问结点是在遍历左子树之后、遍历右子树之前进行，则带圆形的字符标在向左递归返回和向右递归调用之间。由此，只要沿虚线从 $1$ 出发到 $2$ 结束，将沿途所见的三角形（或圆形、或方形）内的字符记下，便得到遍历二叉树的先序（或中序、或后序）序列。例如，从下图 (b) 分别可得下图 (a) 所示表达式的前缀表示（ $-*abc$ ）、中缀表示（ $a*b-c$ ）和后缀表示（ $ab*c-$ ）。

- <spam id="3种遍历过程示意图">3 种遍历过程示意图：</spam>
  ![3种遍历过程示意图](https://static.owo.cab/notes/image/cs/ds/chapter05/3种遍历过程示意图.webp "3种遍历过程示意图")

根据前面 3.4.4 小节的内容，可利用栈将递归算法改写成非递归算法，如下算法所示。例如，从中序遍历递归算法执行过程中递归工作栈的状态可见：
1. 工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针，则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的指针进栈；
2. 若栈顶记录中的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层（即栈顶记录）中指针所指的根结点；
3. 若是从右子树返回，则表明当前层的遍历结束，应继续退栈。从另一个角度看，这意味着遍历右子树时不再需要保存当前层的根指针，直接修改栈顶记录中的指针即可。

> ***算法：中序遍历的非递归算法***
> 
> **【算法步骤】**
> 
> 1. 初始化一个空栈 `S`，指针 `p` 指向根结点。
> 2. 申请一个结点空间 `q` ，用来存放栈顶弹出的元素。
> 3. 当 `p` 非空或者栈 `S` 非空时，循环执行以下操作：
>    - 如果 `p` 非空，则将 `p` 进栈， `p` 指向该结点的左孩子；
>    - 如果 `p` 为空，则弹出栈顶元素并访问，将 `p` 指向该结点的右孩子。
> 
> **【算法描述】**
> 
> ```cpp
> void InorderTraverse(BiTree T)
> {   // 中序遍历二叉树 T 的非递归算法
>     InitStack(S);
>     p = T;
>     q = new BiTNode;
>     while (p || !StackEmpty(S))
>     {
>         if (p)                  // p 非空
>         {
>             Push(S, p);         // 根指针进栈
>             p = p->lchild;      // 根指针进栈，遍历左子树
>         }
>         else                    // p 为空
>         {
>             Pop(S, q);          // 退栈
>             cout << q->data;    // 访问根结点
>             p = q->rchild;      // 遍历右子树
>         }
>     } // while
> }
> ```
> 
> 按上述算法，[*上图 (a)*](#3种遍历过程示意图) 所示的二叉树的中序非递归遍历的栈 `S` 的变化过程如下图所示。
> 
> - 非递归中序遍历时栈 `S` 的变化情况：
>   ![非递归中序遍历时栈S的变化情况](https://static.owo.cab/notes/image/cs/ds/chapter05/非递归中序遍历时栈S的变化情况.webp "非递归中序遍历时栈S的变化情况")
> 
> **【算法分析】**
> 
> 无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含 $n$ 个结点的二叉树，其时间复杂度均为 $O(n)$  。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为 $n$ ，则空间复杂度也为 $O(n)$ 。二叉树的先序、中序和后序遍历是最常用的三种遍历方式。此外，还有一种按层次遍历二叉树的方式，这种方式按照“从上到下，从左到右”的顺序遍历二叉树，即先遍历二叉树第一层的结点，然后是第二层的结点，直到最底层的结点，对每一层的遍历按照从左到右的次序进行。例如，[*上图 (a)*](#3种遍历过程示意图) 所示的二叉树的层次遍历序列是 $-*cab$ 。层次遍历不是一个递归过程，层次遍历算法的实现可以借助队列这种数据结构，这里不做详细讨论。

<br>

### 根据遍历序列确定二叉树
从前面讨论的二叉树的遍历知道，若二叉树中各结点的值均不相同，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的。反过来，若已知二叉树遍历的任意两种序列，能否确定这棵二叉树呢？这样确定的二叉树是否是唯一的呢？

由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。根据定义，二叉树的先序遍历是先访问根结点，其次再按先序遍历方式遍历根结点的左子树，最后按先序遍历方式遍历根结点的右子树。这就是说，在先序序列中，第一个结点一定是二叉树的根结点。另一方面，中序遍历是先遍历左子树，然后访问根结点，最后再遍历右子树。这样，根结点在中序序列中必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，而后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。这样，就确定了二叉树的三个结点。同时，左子树和右子树的根结点又可以分别把左子序列和右子序列划分成两个子序列，如此递归下去，当取尽先序序列中的结点时，便可以得到一棵二叉树。

同理，由二叉树的后序序列和中序序列也可唯一地确定一棵二叉树。因为，依据后序遍历和中序遍历的定义，后序序列的最后一个结点，就如同先序序列的第一个结点一样，可将中序序列分成两个子序列，分别为这个结点左子树的中序序列和右子树的中序序列，再拿出后序序列的倒数第二个结点，并继续分割中序序列，如此递归下去，当倒着取尽后序序列中的结点时，便可以得到一棵二叉树。

**例5.1** 已知一棵二叉树的中序序列和后序序列分别是 $BDCEAFHG$ 和 $DECBHGFA$ ，请画出这棵二叉树。

1. 由后序遍历特征，根结点必在后序序列尾部，即根结点是 $A$ ；
2. 由中序遍历特征，根结点必在其中间，而且其左部必全部是左子树子孙（ $BDCE$ ），其右
部必全部是右子树子孙（ $FHG$ ）；
3. 继而，根据后序中的 $DECB$ 子树可确定 $B$ 为 $A$ 的左孩子，根据 $HGF$ 子串可确定 $F$ 为 $A$ 的右孩子；依此类推，可以唯一地确定一棵二叉树，如图所示。

- 由中序序列和后序序列确定的二叉树：
  ![由中序序列和后序序列确定的二叉树](https://static.owo.cab/notes/image/cs/ds/chapter05/由中序序列和后序序列确定的二叉树.webp "由中序序列和后序序列确定的二叉树")

但是，由一棵二叉树的先序序列和后序序列不能唯一确定一棵二叉树，因为无法确定左右子树两部分。例如，如果有先序序列 $AB$ ，后序序列 $BA$ ，因为无法确定 $B$ 为左子树还是右子树，所以可得到如图所示的两棵不同的二叉树。

- 两颗不同的二叉树：
  ![两颗不同的二叉树](https://static.owo.cab/notes/image/cs/ds/chapter05/两颗不同的二叉树.webp "两颗不同的二叉树")

<br>

### 二叉树遍历算法的应用
“遍历”是二叉树各种操作的基础，假设访问结点的具体操作不仅仅局限于输出结点数据域的值，而把“访问”延伸到对结点的判别、计数等其他操作，可以解决一些关于二叉树的其他实际问题。如果在遍历过程中生成结点，这样便可建立二叉树的存储结构。

1. **创建二叉树的存储结构——二叉链表**
   
   为简化问题，设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表， `T` 为指向根结点的指针，对于给定的一个字符序列，依次读入字符，从根结点开始，递归创建二叉树。
      
   > ***算法：先序遍历的顺序建立二叉链表***
   > 
   > **【算法步骤】**
   > 
   > 1. 扫描字符序列，读入字符 `ch` 。
   > 2. 如果 `ch` 是一个 `#` 字符，则表明该二叉树为空树，即 `T` 为 `NULL` ；否则执行以下操作：
   >    - 申请一个结点空间 `T` ；
   >    - 将 `ch` 赋给 `T->data` ；
   >    - 递归创建 `T` 的左子树；
   >    - 递归创建 `T` 的右子树。
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > void CreateBiTree(BiTree &T)
   > {   // 按先序次序输人二叉树中结点的值（一个字符)，创建二叉链表表示的二叉树 T
   >     cin >> ch;
   >     if (ch == '#')
   >         T = NULL;                   // 递归结束，建空树
   >     else                            // 递归创建二叉树
   >     {
   >         T = new BiTNode;            // 生成根结点
   >         T->data = ch;               // 根结点数据城置为 ch
   >         CreateBiTree(T->lchild);    // 送归创建左子树
   >         CreateBiTree(T->rchild);    // 递归创建右子树
   >     } // else
   > }
   > ```
   
   - 链表存储结构：
     ![链表存储结构](https://static.owo.cab/notes/image/cs/ds/chapter05/链表存储结构.webp "链表存储结构")
   
   例如，对上图 (b) 所示的二叉树，读入字符的顺序为： `ABC#DE#G##F###` （其中 `#` 表示空树），可建立相应的二叉链表。

<br>

2. **复制二叉树**
   
   复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉树的特点，复制步骤如下：若二叉树不空，则首先复制根结点，这相当于二叉树先序遍历算法中访问根结点的语句；然后分别复制二叉树根结点的左子树和右子树，这相当于先序遍历中递归遍历左子树和右子树的语句。因此，复制函数的实现与二叉树先序遍历的实现非常类似。
   
   > ***算法：复制二叉树***
   > 
   > **【算法步骤】**
   > 
   > 如果是空树，递归结束，否则执行以下操作：
   > - 申请一个新结点空间，复制根结点；
   > - 递归复制左子树；
   > - 递归复制右子树。
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > void Copy(BiTree T, BiTree &NewT)
   > {   // 复制一棵和T完全相同的二叉树
   >     if (T == NULL)                      // 如果是空树，递归结束
   >     {
   >         NewT = NULL;
   >         return;
   >     }
   >     else
   >     {
   >         NewT = new BiTNode;
   >         NewT->data = T->data;           // 复制根结点
   >         copy(T->lchild, NewT->lchild);  // 递归复制左子树
   >         Copy(T->rchild, NewT->rchild);  // 递归复制右子树
   >     } // else
   > }
   > ```

<br>

3. **计算二叉树的深度**
   
   二叉树的深度为树中结点的最大层次，二叉树的深度为左右子树深度的较大者加 1。
   
   > ***算法：计算二叉树的深度***
   > 
   > **【算法步骤】**
   > 
   > 如果是空树，递归结束，深度为 0，否则执行以下操作：
   > - 递归计算左子树的深度记为 `m` ；
   > - 递归计算右子树的深度记为 `n` ；
   > - 如果 `m` 大于 `n` ，二叉树的深度为 `m + 1` ，否则为 `n + 1` 。
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > int Depth(BiTree T)
   > {   // 计算二叉树 T 的深度
   >     if (T == NULL)
   >         return 0;               // 如果是空树，深度为 0，递归结束
   >     else
   >     {
   >         m = Depth(T->lchild);   // 递归计算左子树的深度记为 m
   >         n = Depth(T->rchild);   // 递归计算右子树的深度记为 n
   >         if (m > n)              // 二叉树的深度为 m 与 n 的较大者加 1
   >             return (m + 1);
   >         else
   >             return (n + 1);
   >     }
   > }
   > ```
   
   显然，计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。

<br>

4. **统计二叉树中结点的个数**
   
   如果是空树，则结点个数为 0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上 1。
   
   > ***算法：统计二叉树中结点的个数***
   > 
   > **【算法描述】**
   > 
   > ```cpp
   > int NodeCount(BiTree T)
   > {   // 统计二叉树 T 中结点的个数
   >     if (T == NULL)  // 如果是空树，则结点个数为 0，递归结束
   >         return 0;
   >     else            // 否则结点个数为左子树的结点个数 + 右子树的结点个数 + 1
   >         return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;
   > }
   > ```
   
   读者可以模仿此算法，写出以下算法：统计二叉树中叶结点（度为 0）的个数，度为 1 的结点个数和度为 2 的结点个数。算法实现的关键是如何表示度为 0、度为 1 或度为 2 的结点。


---


## 5.5.2 线索二叉树

<br>

### 线索二叉树的基本概念
遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作，使每个结点（除第一个和最后一个外）在这些线性序列中有且仅有一个直接前驱和直接后继（在不至于混淆的情况，后续描述中省去“直接”二字）。例如在 [表达式(a+b*(c-d)-e/f)的二叉树图](#表达式(a+b*(c-d)-e/f)的二叉树) 所示的二叉树结点的中序序列 $a+b*c-d-e/f$ 中，“ $c$ ”的前驱是“ $*$ ”，后继是“ $-$ ”。

但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点在任一序列中的前驱和后继信息，这种信息只有在遍历的动态过程中才能得到，为此引入线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。

虽然可以在每个结点中增加两个指针域来存放在遍历时得到的有关前驱和后继信息，但这样做使得结构的存储密度大大降低。由于有 $n$ 个结点的二叉链表中必定存在 $n+1$ 个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。

试做如下规定：若结点有左子树，则其 `lchild` 域指示其左孩子，否则令 `lchild` 域指示其前驱；若结点有右子树，则其 `rchild` 域指示其右孩子，否则令 `rchild` 域指示其后继。为了避免混淆，尚需改变结点结构，增加两个标志域，其结点形式如表所示。

- 线索二叉树的结点形式：
  | `lchild` | `LTag` | `data` | `RTag` | `rchild` |
  |:--------:|:------:|:------:|:------:|:--------:|

其中：

$$LTag=\left\{\begin{matrix} 0 & lchild域指示结点的左孩子\\ 1 & lchild域指示结点的前驱\end{matrix}\right.$$

$$RTag=\left\{\begin{matrix} 0 & rchild域指示结点的右孩子\\ 1 & rchild域指示结点的前驱\end{matrix}\right.$$

**二叉树的二叉线索类型定义如下：**

```cpp
// -----二叉树的二叉线索存储表示-----
typedef struct BiThrNode
{
    TElemType data;
    struct BiThrNode * lchild, * rchild;    // 左右孩子指针
    int LTag, RTag;                         // 左右标志
} BiThrNode, * BiThrTree;
```

以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点前驱和后继的指针，叫做线索。加上线索的二叉树称之为线索二叉树（Threaded Binary Tree）。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。

- <spam id="线索二叉树及其存储结构">线索二叉树及其存储结构</spam>：
  ![线索二叉树及其存储结构](https://static.owo.cab/notes/image/cs/ds/chapter05/线索二叉树及其存储结构.webp "线索二叉树及其存储结构")

例如上图 (a) 所示为中序线索二叉树，与其对应的中序线索链表如图 (b) 所示。其中实线为指针（指向左、右子树），虚线为线索（指向前驱和后继）。为了方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其 `lchild` 域的指针指向二叉树的根结点，其 `rchild` 域的指针指向中序遍历时访问的最后一个结点；同时，令二叉树中序序列中第一个结点的 `lchild` 域指针和最后一个结点 `rchild` 域的指针均指向头结点。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。

<br>

### 构造线索二叉树
由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程即为在遍历的过程中修改空指针的过程，可用递归算法。对二叉树按照不同的遍历次序进行线索化，可以得到不同的线索二叉树，包括先序线索二叉树、中序线索二叉树和后序线索二叉树。下面重点介绍中序线索化的算法。

为了记下遍历过程中访问结点的先后关系，附设一个指针 `pre` 始终指向刚刚访问过的结点，而指针 `p` 指向当前访问的结点，由此记录下遍历过程中访问结点的先后关系。[*算法：以结点 `p` 为根的子树中序线索化*](#算法：以结点p为根的子树中序线索化) 是对树中任意一个结点p为根的子树中序线索化的过程，[*算法：带头结点的二叉树中序线索化*](#算法：带头结点的二叉树中序线索化) 通过调用 [*算法：以结点 `p` 为根的子树中序线索化*](#算法：以结点p为根的子树中序线索化) 来完成整个二叉树的中序线索化。

> <spam id="算法：以结点p为根的子树中序线索化">***算法：以结点 `p` 为根的子树中序线索化***</spam>
> 
> **【算法步骤】**
> 
> 1. 如果 `p` 非空，左子树递归线索化。
> 2. 如果 `p` 的左孩子为空，则给 `p` 加上左线索，将其 `LTag` 置为 `1` ，让 `p` 的左孩子指针指向 `pre` （前驱）；否则将 `p` 的 `LTag` 置为 `0` 。
> 3. 如果 `pre` 的右孩子为空，则给 `pre` 加上右线索，将其 `RTag` 置为 `1` ，让 `pre` 的右孩子指针指向 `p` （后继）；否则将 `pre` 的 `RTag` 置为 `0` 。
> 4. 将 `pre` 指向刚访问过的结点 `p` ，即 `pre = p` 。
> 5. 右子树递归线索化。
> 
> **【算法描述】**
> 
> ```cpp
> void InThreading(BiThrTree p)
> {   // pre 是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建线索
>     if (p)
>     {
>         InThreading(p->lchild); // 左子树递归线索化
>         if (!p->lchild)         // p 的左孩子为空
>         {
>             p->LTag = 1;        // 给 p 加上左线索
>             p->lchild = pre;    // p 的左孩子指针指向 pre (前驱)
>         } // if
>         else
>             p->LTag = 0;
>         if (!pre->rchild)       // pre 的右孩子为空
>         {
>             pre->RTag = 1;      // 给 pre 加上右线索
>             pre->rchild = p;    // pre 的右孩子指针指向 p (后继)
>         } // if
>         else
>             pre->RTag = 0;
>         pre = p;                // 保持 pre 指向 p 的前驱
>         InThreading(p->rchild); // 右子树递归线索化
>     }
> }
> ```

> <spam id="算法：带头结点的二叉树中序线索化">***算法：带头结点的二叉树中序线索化***</spam>
> 
> **【算法描述】**
> 
> ```cpp
> void InorderThreading(BiThrTree &Thrt, BiThrTree T)
> {   // 中序遍历二叉树 T，并将其中序线索化，Thrt 指向头结点
>     Thrt = new BiThrNode;       // 建头结点
>     Thrt->LTag = 0;             // 头结点有左孩子，若树非空，则其左孩子为树根
>     Thrt->RTag = 1;             // 头结点的右孩子指针为右线索
>     Thrt->rchild = Thrt;        // 初始化时右指针指向自己
>     if (!T)
>         Thrt->lchild = Thrt;    // 若树为空，则左指针也指向自己
>     else
>     {
>         Thrt->lchild = T;       // 头结点的左孩子指向根
>         pre = Thrt;             // pre 初值指向头结点
>         InThreading(T);         // 调用 [算法：以结点 p 为根的子树中序线索化]，对以T为根的二叉树进行中序线索化
>         pre->rchild = Thrt;     // [算法：以结点 p 为根的子树中序线索化] 结束后，pre 为最右结点，pre 的右线索指向头结点
>         pre->RTag = 1;
>         Thrt->rchild = pre;     // 头结点的右线索指向pre
>     }
> }
> ```

<br>

### 遍历线索二叉树
由于有了结点的前驱和后继信息，线索二叉树的遍历和在指定次序下查找结点的前驱和后继算法都变得简单。因此，若需经常查找结点在所遍历线性序列中的前驱和后继，则采用线索链表作为存储结构。

下面分 3 种情况讨论在线索二叉树中如何查找结点的前驱和后继。

1. **在中序线索二叉树中查找**
   1. 查找 `p` 指针所指结点的前驱：
      - 若 `p->LTag` 为 `1` ，则 `p` 的左链指示其前驱；
      - 若 `p->LTag` 为 `0` ，则说明 `p` 有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）。
   2. 查找 `p` 指针所指结点的后继：
      - 若 `p->RTag` 为 `1` ，则 `p` 的右链指示其后继，以 [*上图*](#线索二叉树及其存储结构) 所示的中序线索树为例来看，结点 `b` 的后继为结点 `*` ；
      - 若 `p->RTag` 为 `0` ，则说明 `p` 有右子树。根据中序遍历的规律可知，结点的后继应是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。例如在找结点 `*` 的后继时，首先沿右指针找到其右子树的根结点 `-` ，然后顺其左指针往下直至其左标志为 `1` 的结点，即为结点 `*` 的后继，在图中是结点 `c` 。

2. **在先序线索二叉树中查找**
   1. 查找 `p` 指针所指结点的前驱：
      - 若 `p->LTag` 为 `1` ，则 `p` 的左链指示其前驱；
      - 若 `p->LTag` 为 `0` ，则说明 `p` 有左子树。此时 `p` 的前驱有两种情况：若 `*p` 是其双亲的左孩子，则其前驱为其双亲结点；否则应是其双亲的左子树上先序遍历最后访问到的结点。
   2. 查找 `p` 指针所指结点的后继：
      - 若 `p->RTag` 为 `1` ，则 `p` 的右链指示其后继；
      - 若 `p->RTag` 为 `0` ，则说明 `p` 有右子树。按先序遍历的规则可知， `*p` 的后继必为其左子树根（若存在）或右子树根。

3. **在后序线索二叉树中查找**
   1. 查找 `p` 指针所指结点的前驱：
      - 若 `p->LTag` 为 `1` ，则 `p` 的左链指示其前驱；
      - 若 `p->LTag` 为 `0` ，当 `p->RTag` 也为 `O` 时，则 `p` 的右链指示其前驱；若 `p->LTag` 为 `0` ，而 `p->RTag` 为 `1` 时，则 `p` 的左链指示其前驱。
   2. 查找 `p` 指针所指结点的后继情况比较复杂，分以下情况讨论：
      - 若 `*p` 是二叉树的根，则其后继为空；
      - 若 `*p` 是其双亲的右孩子，则其后继为双亲结点；
      - 若 `*p` 是其双亲的左孩子，且 `*p` 没有右兄弟，则其后继为双亲结点；
      - 若 `*p` 是其双亲的左孩子，且 `*p` 有右兄弟，则其后继为双亲的右子树上按后序遍历列出的第一个结点（即右子树中“最左下”的叶结点）。

- 后序后继线索二叉树：
  ![后序后继线索二叉树](https://static.owo.cab/notes/image/cs/ds/chapter05/后序后继线索二叉树.webp "后序后继线索二叉树")

例如，上图所示为后序线索二叉树，结点 $B$ 的后继为结点 $C$ ，结点 $C$ 的后继为结点 $D$ ，结点 $F$ 的后继为结点 $G$ ，而结点 $D$ 的后继为结点 $E$ 。

可见，在先序线索化树上找前驱或在后序线索化树上找后继时都比较复杂，此时若需要，可直接建立含 4 个指针的线索链表。

由于有了结点的前驱和后继的信息，线索二叉树的遍历操作无需设栈，避免了频繁的进栈、出栈，因此在时间和空间上都较遍历二叉树节省。如果遍历某种次序的线索二叉树，则只要从该次序下的根结点出发，反复查找其在该次序下的后继，直到叶子结点。下面以遍历中序线索二叉树为例介绍该算法。

> ***算法：遍历中序线索二叉树***
> 
> **【算法步骤】**
> 
> 1. 指针 `p` 指向根结点。
> 2. `p` 为非空树或遍历未结束时，循环执行以下操作：
>    - 沿左孩子向下，到达最左下结点 `*p` ，它是中序的第一个结点；
>    - 访问 `*p` ；
>    - 沿右线索反复查找当前结点 `*p` 的后继结点并访问后继结点，直至右线索为 `0` 或者遍历结束；
>    - 转向 `p` 的右子树。
> 
> **【算法描述】**
> 
> ```cpp
> void InOrderTraverse_Thr(BiThrTree T)
> {   // T 指向头结点，头结点的左链 lchild 指向根结点，可参见 [算法：带头结点的二叉树中序线索化]
>     // 中序遍历二叉线索树 T 的非递归算法，对每个数据元素直接输出
>     p = T->lchild;          // p 指向根结点
>     while (p != T)          // 空树或遍历结束时，p == T
>     {
>         while (p->LTag == 0)
>             p = p->lchild;  // 沿左孩子向下
>         cout << p->data;    // 访问其左子树为空的结点
>         while (p->RTag == 1 && p->rchild != T)
>         {
>             p = p->rchild;  // 沿右线索访问后继结点
>             cout << p->data;
>         }
>         p = p->rchild;      // 转向 p 的右子树
>     }
> }
> ```
> 
> **【算法分析】**
> 
> 遍历线索二叉树的时间复杂度为 $O(n)$ ，空间复杂度为 $O(1)$ ，这是因为线索二叉树的遍历不需要使用栈来实现递归操作。
