## 第 1 章 绪论

### 1.1 数据结构基础概念

<br>

#### 数据
数据是描述客观事物的数值、字符以及能输入机器且能被处理的各种符号集合。

<br>

#### 数据元素
数据元素是组成数据的基本单位，是数据集合的个体。

<br>

#### 数据对象
数据对象是性质相同的数据元素的集合，是数据的一个子集。

> ***数据概念归纳如下：***
> - **数据特点**：
>   - 可**被计算机接收**（与计算机的关联性）
>   - 可**被加工**（能被处理）
> - **数据构成**：
>   - **数据元素**——组成数据**基本单位**（是数据集合的个体）
>   - **数据对象**——**性质相同**的数据元素的**集合**（是数据集合的子集）

<br>

#### 数据结构
数据结构是指相互之间存在一种或多种特定关系的数据元素集合，是**带有结构**和**数据元素**的集合。

<br>

#### 数据类型
数据类型是一组性质相同的值集合以及定义在这个值几何上的一组操作的总称。

> ***数据类型分类：***
> - **原子类型**
>   - 不可再分的
> - **结构类型**
>   - 可以分解的
>   - 成分可以是原子的，也可以是结构的

<br>

#### 抽象数据类型
*抽象的本质是抽取反映问题的本质点，而忽略非本质的细节。*

1. **数据的抽象**
   高级语言提供整型、实型、字符、记录、文件、指针等多种数据类型，可以利用这些类型构造出像栈、队列、树、图等复杂的抽象数据类型。
    
2. **抽象数据类型（ADT）**
   抽象数据类型（Abstract Data Type, ADT）定义了一个**数据对象**、**数据对象中各元素间的结构关系**以及**一组处理数据的操作**。

   抽象数据类型最重要的特点是**数据抽象**与**信息屏蔽**。

   ADT包括**数据对象**、**数据元素**间的**结构关系**、**操作**三个部分。

   <br>

   > ***ADT定义格式有多种，下为一种方式：***
   > ```
   > ADT <ADT名>
   > {
   >     数据对象：<数据对象的定义>
   >     结构关系：<结构关系的定义>
   >     基本操作：<基本操作的定义>
   > } ADT <ADT名>
   > ```


---


### 1.2 数据结构的内容

<br>

#### 逻辑结构
数据的逻辑结构是指数据元素之间**逻辑关系描述**。

形式定义为：数据结构是一个二元组

$$Data \_ Structure = (D, R)$$

其中， $D$ 是数据元素的有限集， $R$ 是 $D$ 上关系的有限集。

> **例如：**
> 
> $DS_2 = (D_2, R_2)$
> 
> $D_2 = \{ a, b, c, d, e, f \}$
> 
> $R_2 = \{ T \}$
> 
> $T = \{ <a, b>, <a, c>, <a, d>, <c, e>, <c, f> \}$

根据数据元素之间关系的不同特性，通常有以下四类基本结构：
1. **集合结构**：结构中的数据元素之间除了**同属于一个集合**的关系外，**无任何其他关系**。
2. **线性结构**：结构中的数据元素之间存在着**一对一的线性关系**。
3. **树状结构**：结构中的数据元素之间存在着**一对多的层次关系**。
4. **图状结构或网状结构**：结构中的数据元素之间存在着**多对多的任意关系**。

> ***数据的四类基本逻辑结构可概括如下：***
> - **线性结构**——线性表、栈、队、字符串、数组、广义表
> - **非线性结构**——树、图

<br>

#### 存储结构
存储结构（又称物理结构）是**逻辑结构在计算机中的存储映像**。
> 包括**数据元素映像**和**关系映像**。
> 是**逻辑结构**在计算机中的**实现**。
> 包括**数据元素的表示**和**关系的表示**。

**形式化描述**：对于一种数据结构 $(D, R)$，要将 $D$ 存入计算机中，建立一种从 $D$ 的数据元素到存储空间 $M$ 单元的映像 $S$，即 $D → M$ ，也就是说对于每一个 $d$， $d ∈ D$ ，都有唯一的 $z ∈ M$ 使 $S(D) = Z$，同时这个映像必须明显或隐含地体现关系 $R$。

> ***逻辑结构与存储结构的关系***
> - 存储结构是**逻辑关系的映像**与**元素本身的映像**。
> - **逻辑结构是数据结构的抽象，存储结构是数据结构的实现**，两者综合起来建立了**数据元素之间的结构关系**。

> ***数据元素之间的关系在计算机中有两种不同的表示方法：***
> - **顺序映像**（顺序存储结构）
> - **非顺序映像**（非顺序存储结构）

<br>

#### 运算集合
讨论数据结构的目的是为了在计算机中实现操作，因此在结构上的运算集合是很重要的部分。数据结构就是研究一类数据的表示及其相关的运算操作。

如在某工资表中，可以采用**线性表的逻辑结构**；怎么存放就是具体**存储结构**的问题了；对工资表作出的增、删、改等操作就是数据的**操作集合**。

<br>

**综上所述，按某种逻辑关系组织起来的一批数据，按一定的映像方式把它们存放在计算机的存储器中，并在这些数据上定义一个运算的集合，这些是数据结构课程的基本内容。**


---


### 1.3 算法

<br>

#### 算法定义
算法（Algorithm）是规则的有限集合，是为解决特定问题而规定的一系列操作。

<br>

#### 算法的特性
1. **有限性**：有限步骤之内正常结束，不能形成无穷循环。
2. **确定性**：算法中的每一个步骤必须有确定含义，无二义性。
3. **可行性**：原则上能精确进行，操作可通过已实现的基本运算执行有次而完成。
4. **输入**：有多个或 0 个输入。
5. **输出**：至少有一个或多个输出。

> 在算法的五大特性中，最基本的是**有限性**、**确定性**和**可行性**这三个特性。

<br>

#### 算法设计的要求
1. **算法的正确性**
    - 算法对于几组输入数据能够得出满足要求的结果。
    - 算法对于精心选择的典型、苛刻而带有刁难性的输入数据能够得出满足要求的结果。
    - 算法对于一切合法的输入数据都能产生满足要求的结果。

    > 达到第三层含义下的正确是极为困难的，一般情况下，**至少应以第二层含义的正确**作为衡量一个算法是否正确的标准。

2. **可读性**

3. **健壮性（鲁棒性）**

4. **高效率和低存储量**


---


### 1.4 算法描述

<br>

#### 算法、语言、程序的关系
1. **算法**：描述数据对象之间的关系（包括数据逻辑关系、存储关系描述）
2. **描述算法的工具**：算法可用自然语言、框图或高级程序设计语言进行描述。
3. **程序是算法在计算机中的实现**（与所用计算机及所用语言有关）。

<br>

#### 设计实现算法过程的步骤
1. 找出与求解有关的数据元素之间的关系（**建立结构关系**）。
2. **确定**在某一数据对象上所施加的**运算**。
3. 考虑数据元素的**存储表示**。
4. 选择**描述算法的语言**。
5. 设计**实现求解的算法**，并**用程序语言加以描述**。

<br>

#### 描述算法的语言选择
以下使用 C 语言，个别之处采用简化示意。


---


### 1.5 算法性能评价

### 1.5.1 算法的时间性能分析

<br>

#### 算法耗费的时间
一个算法的执行时间是指算法中所有语句执行时间的总和。每条语句的执行时间等于该条语句的执行次数乘以执行一次所需的实际时间。

<br>

#### 语句频度
语句频度是指**该语句在一个算法中重复执行的次数。**
一个算法的时间耗费就是该算法中所有语句频度之和。

> ***示例：求两个 n 阶方阵的乘积 `C = A × B`***
> ```c
> #define n 100
> void MatrixMulti(int a[n][n], int b[n][n], int c[n][n])
> {
>     for (int i = 0; i < n; i++)           // n + 1
>         for (int j = 0; j < n; j++)       // n * (n + 1)
>         {
>             c[i][j] = 0;                  // n * n
>             for (int k = 0; k < n; k++)   // n * n * (n + 1)
>                 c[i][j] = c[i][j] + a[i][k] * b[k][j]; // n * n * n
>         }
> }
> ```
> 在每一个语句后面都标示出了其语句频度。
> 该算法中**所有语句的频度之和**（即**算法的时间耗费**）为：
> 
> **$$f(n) = 2n^3 + 3n^2 + 2n + 1$$**

<br>

#### 算法的时间复杂度
为便于比较同一问题的不同算法，通常以算法中**基本操作重复执行的频度**作为度量标准。

算法的时间复杂度 $T(n)$ 是该算法的时间度量，记作 **$$T(n) = O(f(n))$$**

它表示随问题规模 $n$ 的增大，算法的执行时间的增长率和 $F(n)$ 的增长率相同，称作算法的渐近时间复杂度，简称**时间复杂度**。

在上面的算法 `MatrixMulti` 中，由于 $f(n)$ 和 $n^3$ 同阶，或者说数量级相同，因此 $O(n^3)$ 是算法 `MatrixMulti` 的渐近时间复杂度。

<br>

#### 渐近时间复杂度
主要用算法**时间复杂度的数量级**（即算法的**渐近时间复杂度**）来评价一个算法的**时间性能**。

<br>

#### 常用算法时间复杂度
数据结构中常用的时间复杂度频率计数有以下 7 种：
- 常数型： $O(1)$
- 线性型： $O(n)$
- 平方型： $O(n^2)$
- 立方型： $O(n^3)$
- 指数型： $O(2^n)$
- 对数型： $O(log_2n)$
- 二维型： $O(nlog_2n)$

> 一般来说，前三种可实现，后三种虽理论上可实现，但实际上只有当 $n$ 限制在很小的范围内时才有意义。

> 一般情况下，**随 $n$ 的增大， $T(n)$ 的增长较慢的算法为最优算法**，因此应该选择使用多项式阶 $O(n^2)$ 的算法，而避免使用指数阶的算法。

<br>

#### 最坏时间复杂度和平均时间复杂度
算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。
> ***示例：在数值 `A[n]` 中查找给定值 `k` 的算法***
> ```c
> i = n - 1;
> while (i >= 0 && (A[i] != k ))
>     i--;  // 语句 (3)
> return i;
> ```
> 此算法中，`语句 (3)` 的频度不仅**与问题规模 `n` 有关**，还**与 `A` 的各元素值及 `k` 的取值有关**。
> - **最坏情况**：`A` 中没有与 `k` 相等的元素，则 `语句 (3)` 的频度 **$f(n) = n$**。
> - **最好情况**：`A` 中最后一个元素等于 `k`，则 `语句 (3)` 的频度 **$f(n)$** 是**常数 $0$**。


---


### 1.5.2 算法的空间性能分析

<br>

#### 算法耗费的空间
一个算法的占用空间是指算法实际占用的辅助空间总和。
算法空间分析度量的标准并不是计算实际占用空间，而是计算整个算法的**辅助空间单元个数**。

<br>

#### 算法的空间复杂度
算法的空间复杂度 $S(n)$ 定义为该算法所耗费的存储空间的数量级，它是问题规模 $n$ 的函数，记作

**$$S(n) = O(f(n))$$**

若算法执行时所需要的辅助空间相对于数据量而言是一个常数，则称这个算法为原地工作，辅助空间为 $O(1)$ 。

> ***示例：将一维数组 `a` 中的 `n` 个数据逆序存放到原数组中***
> ```c
> // 算法 1
> for (i = 0; i < n; i++)
>     b[i] = a[n - i - 1];
> for (i = 0; i < n; i++)
>     a[i] = b[i];
> ```
> ```c
> // 算法 2
> for (i = 0; i < n / 2; i++)
> {
>     t = a[i];
>     a[i] = a[n - i -1];
>     a[n - i - 1] = t;
> }
> ```
> `算法 1` 的空间复杂度为 **$O(n)$** ，需要**一个大小为 `n` 的辅助数组 `b`**。
> `算法 2` 的空间复杂度为 **$O(1)$** ， 仅需要**一个变量 `t`**，**与问题规模没有关系**。

**算法的时间复杂度和空间复杂度合称为算法的复杂度。**


---


### 1.5.3 算法性能选择
要想使一个算法既占用存储空间少，又运行时间短，而且其他性能也好，这是很难做到的。
只能根据具体情况进行取舍：
1. 若该程序**使用次数较少**，则**力求算法简明易懂**。
2. 对于**反复使用的程序**，应**尽可能选用快速的算法**。
3. 若**待解决的问题数据量极大，计算机的存储空间极小**，则相应算法**主要考虑如何节省空间**。


---


### 1.6 数据结构与 C 语言表示

### 1.6.1 数据结构与程序设计的关联性
编写程序仅仅掌握语言是不够的，还必须掌握数据的组织、存储和运算方法。数据结构是在积累程序设计经验的基础上形成的，是提高程序设计能力的基础和关键所在。

> ***示例：求一名学生 10 次 C 语言程序设计的测试成绩总分与平均分。***
> *这 10 次测验的成绩分别为 80，85，77，56，68，83，90，92，80，98。*
> 
> ```c
> // 示例 1
> int main()
> {
>     int sum, average;
>     int t1, t2, t3, t4, t5, t6, t7, t8, t9, t10; 
>     t1 = 80; t2 = 85; t3 = 77; t4 = 56; t5 = 68;
>     t6 = 83; t7 = 90; t8 = 92; t9 = 80; t10 = 98;
>     sum = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;
>     average = sum / 10;
>     printf("总分 = %d\n", sum);
>     printf("平均分 = %d\n", average);
> }
>```
> 如果要用该程序计算另一名学生的 10 次成绩就得修改程序，测验次数改变也要修改程序，程序扩充性与通用性较差。
> 
> ```c
> // 示例 2
> int main()
> {
>     int sum, average;
>     int i;
>     int t[10] = { 80, 85, 77, 56, 68, 83, 90, 80, 98 };
>     sum = 0;
>     for (int i = 0; i < 10; i++)
>         sum = sum + t[i];
>     average = sum / 10;
>     printf("总分 = %d\n", sum);
>     printf("平均分 = %d\n", average);
> }
> ```
> 根据测试次数与测试成绩的关系，采用数组结构存储测验成绩，可以提高程序的适用范围。
> 
> 分析以上两个程序，虽然都可以正确解决问题，但采用不同的方式存储成绩数据，产生了不同的程序设计方式。


---


### 1.6.2 结构化程序设计与函数的模块化
> Wirth 用“ **$算法 + 数据结构 = 程序$** ”阐释了程序设计的实质，也可以理解为程序是在数据的特定表示方式的基础上，对抽象算法的具体描述，即
> 
> **$$程序结构 = 控制结构 + 数据结构$$**
>
> **结构化程序设计**是为使程序具有合理的结构，以保证程序正确性而规定的一套程序设计的方法。

<br>

#### 结构化程序设计目的
通过设计结构良好的程序，**以程序良好的静态结构来保证程序动态执行的正确性**，使程序易理解、易调试、易维护，以提高软件开发的效率，减少出错率。

<br>

#### 结构化程序设计的构成单元
任何程序都可由**顺序**、**选择**、**重复**三种基本控制结构来组成。

为灵活、方便地处理问题，程序语言中也可引入其他控制结构设施，如 goto 语句。限制 goto 语句的使用是很有必要的。

<br>

#### 结构化程序设计方法
结构化程序设计的概念由 E. W. Dijkstra 于 1969 年提出，强调了从程序结构和风格上来研究程序设计问题。也将此方法称为“自顶而下”或“逐步求精”法。

1. **“自顶而下，逐步求精”。**

2. **“独立功能，一个入口，一个出口”的模块化结构。**

3. **“仅用三种基本控制结构”的设计原则。**


---


### 1.6.3 面向对象与抽象数据类型

<br>

#### 面向对象的概念
Coad 和 Yourdon 给出面向对象的概念： **$面向对象 = 对象 + 类 + 继承 + 通信$** 。
- **对象**：是指在应用问题中出现的各种变体、事件和规格说明等，它是由一组属性和在这组值上的一组服务构成的，其中属性值确定了对象的状态。
- **类**：把具有相同属性和服务的对象归到了同一类，而把一个类中的每一个对象称为该类的一个实例，它们具有相同的服务。
- **继承**：面向对象方法的最有特色的方面。
- 各个类的对象间通过消息进行**通信**。

> **面向对象程序设计的特点是封装性（Encapsulation）、继承性（Inheritance）和多态性（Polymorphism）。**

定义在数据结构上的基本操作主要可列以下五种：
1. **插入**：在数据结构中的指定位置上增添新的数据元素。
2. **删除**：删除数据结构中某个指定的数据元素。
3. **更新**：改变数据结构中某个元素的值，在概念上等价于删除和插入操作的组合。
4. **查找**：在数据结构中寻找满足某个特定要求的数据元素（包括位置和值）。
5. **排序**：（在线性结构中）重新安排数据元素之间的逻辑顺序关系，使数据元素按值由小到大或由大到小的次序排列。

根据增、删、改、查找、排序等基本操作的特性，所有操作可以分为两大类：
- **加工型操作**，其操作的结果改变了结构的值；
- **引用型操作**，其操作的结果不改变结构的值。

> ***结构化的开发方法与面向对象的开发方法的不同之处：***
> - **结构化的开发方法是面向过程的开发方法，首先着眼于系统要实现的功能。从系统的输入、输出出发，分析系统要实现的功能，用自顶向下、逐步细化的方式建立系统的功能结构和相应的程序模块结构。** 一旦程序功能需要修改，就会涉及多个模块的修改。
> - **面向对象的开发方法首先着眼于应用问题所涉及的对象，包括对象、对象属性、要求的操作，从而建立对象结构和为解决问题需要执行的事件序列，据此建立类的继承层次结构，通过各个类的实例之间的消息连接实现所需的功能。** 如果系统功能的需求发生变化，只需修改类中的服务即可，此时类所代表的对象基本不变，从而确保系统不致因修改而退化。
> 
> 与结构化的开发方法相比，采用面向对象开发方法的程序具有更高的可靠性、可修改性、可维护性、可复用性、可适用性和可理解性。

<br>

#### 抽象数据类型与问题求解方法
抽象数据类型集中体现了**程序设计中一些最基本的原则：分解、抽象和信息隐藏**。对一个抽象数据类型，可以用代数系统形式严格地给予定义，而直观上可以把抽象数据类型看成是定义了一组运算的数学模型。

抽象数据类型的概念不仅包含数学模型，同时还包含这个模型上的运算。数据的逻辑结构和运算的定义组成了数据结构**规范**，而数据的存储结构和运算算法的描述构成了数据结构的**实现**。规范是实现的准则和依据，规范指明“做什么”，而实现解决“怎么做”。**一个抽象数据类型确定了一个模型，但将模型的实现细节隐藏起来；它定义了一组运算，但将运算的实现过程隐藏起来。**

> ***用抽象数据类型的概念来指导问题求解的过程：***
> |  **数学模型**  | **→** | **抽象数据类型** | **→** |  **数据结构**  |
> |:--------------:|:-----:|:----------------:|:-----:|:--------------:|
> | **非形式算法** | **→** |  **伪语言程序**  | **→** | **可执行程序** |
>
> 事实上，上表所说明的不仅是问题求解的一般过程，也是目前软件自动生成常用的模式。 $数学模型 → 抽象数据类型 → 数据结构$ ，恰好反映了信息结构转换的三个重要阶段，而在这个转换过程中，**数据结构是基础，抽象数据类型是中枢**。

<br>

#### 抽象数据类型的实现途径
具体定义抽象数据类型需要借助于高级语言，对于抽象数据类型的具体实现则依赖于所选择的高级语言的功能。

1. **传统的面向过程的程序设计**
   如标准 Pascal、C 等面向过程的语言，这类语言利用抽象数据类型进行程序设计的基本方法是，只有嵌入了该类型说明和过程说明之后才可以访问该抽象数据类型，称之为数据结构受限的访问。

2. **“包”、“模型”的设计方法**
   这是面向对象模块结构的表示和实现。每个模块含有一个或多个抽象数据类型，不仅可以单独编译，而且为外部使用抽象数据类型提供了方便。比起第一种方法有了一定的进步。

3. **面向对象的程序设计（Object Oriented Programming, OOP）**
   借助对象描述抽象数据类型，存储结构的说明和操作函数的说明被封装在一个整体结构中，这个整体结构被称为“类”（Class），属于某个“类”的具体变量被称为“对象”（Object）。
   同一种数据类型和不同操作组将组成不同的数据类型，结构说明和过程说明被统一在一个整体对象之中，其中，数据结构的定义为对象的属性域，过程或函数定义在对象中，称为方法（Method），它是对对象的性能描述。

<br>

#### 用 C 语言实现抽象数据类型
ADT 包括定义和实现两方面，其中定义是独立于实现的。定义仅给出一个 ADT 的逻辑特性，不必考虑如何在计算机中实现。

1. **ADT 的定义格式**
   例如：给出“简化线性表”的抽象数据类型的定义。
   
   > **ADT Linear_list** {
   > 
   > &ensp;&ensp;&ensp;&ensp;**数据元素**：所有 $a_i$ 属于统一数据对象， $i = 1, 2, ..., n$ ， $n ≥ 0$ ；
   > 
   > &ensp;&ensp;&ensp;&ensp;**结构关系**：所有数据元素 $a_i(i = 1, 2, ..., n-1)$ 存在次序关系 $<a_i, a_{i+1}>$ , $a_i$ 无前驱， $a_n$ 无后继。
   > 
   > &ensp;&ensp;&ensp;&ensp;**基本操作**：设 $L$ 为 $Linear \_ List$ ，则有
   > 
   > &ensp;&ensp;&ensp;&ensp; ① $InitList(L)$ ：初始化空线性表。
   > 
   > &ensp;&ensp;&ensp;&ensp; ② $ListLength(L)$ ：求线性表的表长。
   > 
   > &ensp;&ensp;&ensp;&ensp; ③ $GetData(L, i)$ ：取线性表的第 $i$ 个元素。
   > 
   > &ensp;&ensp;&ensp;&ensp; ④ $InsList(L, i, b)$ ：在线性表第 $i$ 个位置插入元素 $b$ 。
   > 
   > &ensp;&ensp;&ensp;&ensp; ⑤ $DelList(L, i)$ ：删除线性表的第 $i$ 个数据元素。
   > 
   > } **ADT Linear_list**

   在上述 ADT 中，数据元素所属的数据对象没有局限于一个具体的整型、实型或其他类型，所具有的操作也是抽象的数学特性，并没有具体到某一种计算机语言指令与程序编码。

2. **用 C 语言实现 ADT**
   主要包括以下两个方面：

   1. 通过结构体将 `int` 、 `float` 等基本数据类型组合到一起，构成一个结构体类型，再用 `typedef` 为该类型或该类型指针重新起一个名字，以增强程序的抽象性、简洁性和可读性。即采用 C 语言中 `typedef` 自定义类型来实现。
   2. 用 C 语言的子函数实现各个操作。

   > ***示例：用 C 语言实现复数 ADT 的实例。***
   > ```c
   > typedef struct
   > {
   >     float realpart;
   >     float imagpart;
   > } Complex;
   > 
   > Complex create(float x, float y);
   > Complex add(Complex z1, Complex z2);
   > 
   > int main(void)
   > {
   >     float a, b;
   >     Complex c1, c2, c3;
   > 
   >     printf("\n\n\n  Input realpart and imagpart: ");
   >     scanf("%f%f", &a, &b);
   >     c1 = create(a, b);
   > 
   >     printf("\n\n\n  Input realpart and imagpart: ");
   >     scanf("%f%f", &a, &b);
   >     c2 = create(a, b);
   > 
   >     c3 = add(c1, c2);
   >     printf("\n\n  c1 == %f + %fi", c1.realpart, c1.imagpart);
   >     printf("\n\n  c2 == %f + %fi", c2.realpart, c2.imagpart);
   >     printf("\n\n  c3 == c1 + c2 == %f + %fi", c3.realpart, c3.imagpart);
   >     
   >     return 0;
   > }
   > 
   > Complex create(float x, float y)
   > /* 利用 x, y 创建复数 z，并将 z 返回 */
   > {
   >     Complex z;
   >     z.realpart = x;
   >     z.imagpart = y;
   >     return z;
   > }
   > 
   > Complex add(Complex z1, Complex z2)
   > /* 求复数 z1, z2 的和 sum，并将 sum 返回 */
   > {
   >     Complex sum;
   >     sum.realpart = z1.realpart + z2.realpart;
   >     sum.imagpart = z1.imagpart + z2.imagpart;
   >     return sum;
   > }


---


### 1.6.4 算法描述规范与设计风格

