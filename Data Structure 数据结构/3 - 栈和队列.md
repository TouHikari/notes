# 第 3 章 栈和队列

## 3.1 栈和队列的定义和特点
栈和队列是两种重要的**线性结构**。
从**数据结构角度**看，栈和队列**也是线性表**，其特殊性在子栈和队列的基本操作是线性表操作的子集，它们**是操作受限的线性表**，因此，可称为**限定性的数据结构**。
但从**数据类型角度**看，它们是**和线性表不相同的两类重要的抽象数据类型**。

### 3.1.1 栈的定义和特点
**栈（stack）**是**限定仅在表尾进行插入或删除操作的线性表**。因此，对栈来说，**表尾端**有其特殊含义，**称为栈顶（top）**，相应地，**表头端称为栈底（bottom）**。不含元素的空表称为**空栈**。

假设栈 $S = (a_1, a_2, ..., a_n)$ ，则称 $a_1$ 为栈底元素， $a_n$ 为栈顶元素。栈的修改是按**后进先出**的原则进行的。因此，栈又称为**后进先出（Last In First Out, LIFO）的线性表**。

- 栈：
  ![栈](img/3/栈.jpg "栈")


---


### 3.1.2 队列的定义和特点
和栈相反，**队列（queue）**是一种**先进先出（First In First Out, FIFO）的线性表**。它只允许在表的**一端进行插入**，而在**另一端删除元素**。这和日常生活中的排队是一致的，**最早进入队列的元素最早离开**。在队列中，**允许插入的一端称为队尾（rear）**，**允许删除的一端则称为队头（front）**。

假设队列为 $q = (a_1, a_2, ..., a_n)$ ，那么， $a_1$ 就是队头元素， $a_n$ 则是队尾元素。

- 队列的示意图：
  ![队列的示意图](img/3/队列的示意图.jpg "队列的示意图")


---


## 3.2 案例引入

- **案例3.1：数制的转换**
  十进制数 $N$ 和其他 $d$ 进制数的转换是计算机实现计算的基本问题，其解决方法很多，其中一个简单算法基于下列原理：

  $$N = (N\ \ div\ \ d) × d + N\ mod\ d$$ 

  （其中， $div$ 为整除运算， $mod$ 为求余运算）

  > 例如： $(1348)_{10} = (2504)_8$ ，其运算过程如下：
  > 
  > |   $N$  | $N\ div\ 8$ | $N\ mod\ 8$ |
  > |:------:|:-----------:|:-----------:|
  > | $1348$ |    $168$    |     $4$     |
  > |  $168$ |     $21$    |     $0$     |
  > |  $21$  |     $2$     |     $5$     |
  > |   $2$  |     $0$     |     $2$     |

  假设现要编制一个满足下列要求的程序：对于输入的任意一个非负十进制整数，输出与其等值的八进制数。上述计算过程是从低位到高位顺序产生八进制数的各个数位；而输出过程应从高位到低位进行，恰好和计算过程相反，因而我们可以使用栈来解决这个问题。在计算过程中依次将得到的余数压入栈中，计算完毕后，再依次弹出栈中的余数就是数制转换的结果。

- **案例3.2：括号匹配的检验**
  假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序随意，即 `([ ]( ))` 或 `[([ ][ ])]` 等为正确的格式， `[( ]` 或 `([( ))` 或 `( )])` 均为不正确的格式。检验括号是否匹配的方法可用“期待的急迫程度”这个概念来描述。

  > 例如，考虑下列括号序列：
  > ```c
  > [ ( [ ] [ ] ) ]
  > 1 2 3 4 5 6 7 8
  > ```
  > 
  > 当计算机接受了第一个括号后，它期待着与其匹配的第八个括号的出现，然而等来的却是第二个括号，显然第二个括号的期待急迫性高于第一个括号，此时第一个括号 `[` 只能暂时靠边，而迫切等待与第二个括号相匹配的、第七个括号 `)` 的出现。类似地，因等来的是第三个括号 `[` ，其期待匹配的程度较第二个括号更急迫，则第二个括号也只能靠边，让位于第三个括号。在接受了第四个括号之后，第三个括号的期待得到满足，消解之后，第二个括号的期待匹配就成为当前最急迫的任务了，……，依次类推。可见，这个处理过程恰与栈的特点相吻合。每读入一个括号，若是右括号，则或者使置于栈顶的最急迫的期待得以消解，或者是不合法的情况；若是左括号，则作为一个新的更急迫的期待压入栈中，自然使原有的在栈中的所有未消解的期待的急迫性都降了一级。

- **案例3.3：表达式求值**
  表达式求值是程序设计语言编译中的一个最基本问题，其实现是栈应用的又一个典型例子。“算符优先法”，是一种简单直观、广为使用的表达式求值算法。

  要把一个表达式翻译成正确求值的一个机器指令序列，或者直接对表达式求值，首先要能够正确解释表达式。算符优先法就是根据算术四则运算规则确定的运算优先关系，实现对表达式的编译或解释执行的。

  在表达式计算中先出现的运算符不一定先运算，具体运算顺序是需要通过运算符优先关系的比较，确定合适的运算时机，而运算时机的确定是可以借助栈来完成的。将扫描到的不能进行运算的运算数和运算符先分别压入运算数栈和运算符栈中，在条件满足时再分别从栈中弹出进行运算。

**上述3个应用实例都是借助栈的后进先出的特性来处理问题的，在日常生活中，符合先进先出特性的应用更为常见。**

- **案例3.4：舞伴问题**
  假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头各出一人配成舞伴。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一算法模拟上述舞伴配对问题。

  先入队的男士或女士应先出队配成舞伴，因此该问题具有典型的先进先出特性，可用队列作为算法的数据结构。

  从上面的应用案例可以看出，不论是借助栈还是队列来解决问题，最基本的操作都是“入”和“出”。对于栈，在栈顶插入元素的操作称作“入栈”，删除栈顶元素的操作称作“出栈”；对于队列，在队尾插入元素的操作称作“入队”，在队头删除元素的操作称作“出队”。和线性表一样栈和队列的存储结构也包括顺序和链式两种。


---


## 3.3 栈的表示和操作的实现

### 3.3.1 栈的类型定义
栈的基本操作除了入栈和出栈外，还有栈的初始化、栈空的判定，以及取栈顶元素等。

> ***下面给出栈的抽象数据类型定义：***
> 
> **$ADT\ Stack$** {
> 
> &ensp;&ensp;&ensp;&ensp;**数据对象**： $D = \{ a_i\ |\ a_i∈ElemSet,\ i = 1, 2, ..., n,\ n ≥ 0 \}$
> 
> &ensp;&ensp;&ensp;&ensp;**数据关系**： $R = \{ \langle a_{i-1}, a_i \rangle\ |\ a_{i-1}, a_i∈D,\ i = 2, ..., n \}$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;约定 $a_n$ 端为栈顶， $a_1$ 端为栈底。
> 
> &ensp;&ensp;&ensp;&ensp;**基本操作**：
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $InitStack(\& S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：构造一个空栈 $S$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $DestroyStack(\& S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：栈 $S$ 被销毁。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $ClearStack(\& S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：将 $S$ 清为空栈。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StackEmpty(S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：若栈 $S$ 为空栈，则返回 $true$ ，否则返回 $false$ 。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StackLength(S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：返回 $S$ 的元素个数，即栈的长度。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $GetTop(S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在且非空。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：返回 $S$ 的栈顶元素，不修改栈顶指针。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $Push(\& S, e)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：插入元素 $e$ 为新的栈顶元素。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $Pop(\& S, \& e)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在且非空。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：删除 $S$ 的栈顶元素，并用 $e$ 返回其值。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp; $StackTraverse(S)$
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 初始条件：栈 $S$ 已存在且非空。
> 
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 操作结果：从栈底到栈顶依次对 $S$ 的每个数据元素进行访问。
> 
> } **$ADT\ Stack$**

和线性表类似，栈也有两种存储表示方法，分别称为**顺序栈**和**链栈**。


---


### 3.3.2 顺序栈的表示和实现
顺序栈是指**利用顺序存储结构实现**的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针 `top` 指示栈顶元素在顺序栈中的位置。

通常习惯的做法是：以 `top = 0` 表示空栈，鉴于 C 语言中数组的下标约定从 `0` 开始，则当以 C 语言作描述语言时，如此设定会带来很大不便，因此另设指针 `base` 指示栈底元素在顺序栈中的位置。当 `top` 和 `base` 的值相等时，表示空栈。

**顺序栈的定义如下**：

```c
//-----顺序栈的存储结构-----
#define MAXSIZE 100     // 顺序栈存储空间的初始分配量
typedef struct {
    SElemType * base;   // 栈底指针
    SElemType * top;    // 栈顶指针
    int stacksize;      // 栈可用的最大容量
} SqStack;
```

> ***说明***：
> 1. `base` 为栈底指针，初始化完成后，栈底指针 `base` 始终指向栈底的位置，若 `base` 的值为 `NULL` ，则表明栈结构不存在。
>    `top` 为栈顶指针，其初值指向栈底。每当插入新的栈顶元素时，指针 `top` 增 `1` ；删除栈顶元素时，指针 `top` 减 `1` 。
>    因此，栈空时， `top` 和 `base` 的值相等，都指向栈底；栈非空时， `top` 始终指向栈顶元素的上一个位置。
> 
> 2. `stacksize` 指示栈可使用的最大容量，后面算法的初始化操作为顺序栈动态分配 `MAXSIZE` 大小的数组空间，将 `stacksize` 置为 `MAXSIZE` 。

- 栈中元素和栈指针之间的关系：
  ![栈中元素和栈指针之间的关系](img/3/栈中元素和栈指针之间的关系.jpg "栈中元素和栈指针之间的关系")

由于顺序栈的插入和删除操作只在栈顶进行，因此顺序栈的基本操作比顺序表要简单得多。

<br>

#### 初始化
顺序栈的初始化操作就是为顺序栈**动态分配一个预定义大小的数组空间**。

> ***算法：顺序栈的初始化***
> **【算法步骤】**
> 1. 为顺序栈动态分配一个最大容量为 `MAXSIZE` 的数组空间，使 `base` 指向这段空间的基地址，即栈底。
> 2. 栈顶指针 `top` 初始为 `base` ，表示栈为空。
> 3. `stacksize` 置为栈的最大容量 `MAXSIZE` 。
> 
> **【算法描述】**
> ```c
> Status InitStack(SqStack &S)
> {   // 构造一个空栈 s
>     S.base = new SElemType[MAXSIZE];    // 为顺序栈动态分配一个最大容量为 MAXSIZE 的数组空间
>     if (!S.base)
>         exit(OVERFLOW);                 // 存储分配失败
>     S.top = S.base;                     // top 初始为 base，空栈
>     S.stacksize = MAXSIZE;              // stacksize 置为栈的最大容量 MAXSIZE
>     return OK;
> }
> ```

<br>

#### 入栈
入栈操作是指**在栈顶插入一个新的元素**。

> ***算法：顺序栈的入栈***
> **【算法步骤】**
> 1. 判断栈是否满，若满则返回 `ERROR` 。
> 2. 将新元素压入栈顶，栈顶指针加 $1$。
> 
> 【算法描述】
> ```c
> Status Push(SqStack &S, SElemType e)
> {   //插入元素 e 为新的栈顶元素
>     if (S.top-S.base == s.stacksize)
>         return ERROR;
>     *(S.top++) = e;   // 栈满
>     return OK;      // 元素 e 压入栈顶，栈顶指针加 1
> }
> ```

<br>

#### 出栈
出栈操作是**将栈顶元素删除**。

> ***算法：顺序栈的出栈***
> **【算法步骤】**
> 1. 判断栈是否空，若空则返回 `ERROR` 。
> 2. 栈顶指针减 $1$ ，栈顶元素出栈。
> 
> **【算法描述】**
> ```c
> Status Pop(SqStack &S, SElemType &e)
> {   // 删除 S 的栈顶元素，用 e 返回其值
>     if(S.top == S.base)
>         return ERROR;   // 栈空
>     e = *(--S.top);     // 栈顶指针减 1，将栈顶元素赋给 e
>     return OK;
> }
> ```

<br>

#### 取栈顶元素
当栈非空时，此操作**返回当前栈顶元素的值**，栈顶指针保持不变。

> ***算法：取顺序栈的栈顶元素***
> **【算法描述】**
> ```c
> SElemType GetTop(SqStack S)
> {   //返回 s 的栈顶元素，不修改栈顶指针
>     if (S.top != S.base)        // 栈非空
>         return *(S.top - 1);    // 返回栈顶元素的值，栈顶指针不变
> }
> ```

由于顺序栈和顺序表一样，**受到最大空间容量的限制**，虽然可以在“满员”时重新分配空间扩大容量，但工作量较大，**应该尽量避免**。因此在应用程序无法预先估计栈可能达到的最大容量时，还是**应该使用链栈**。


---


### 3.3.3 链栈的表示和实现
链栈是指采用链式存储结构实现的栈。通常链栈用单链表来表示，如图所示。

- 链栈示意图：
  ![链栈示意图](img/3/链栈示意图.jpg "链栈示意图")

链栈的结点结构与单链表的结构相同，在此用 `StackNode` 表示，定义如下：

```c
//-----链栈的存储结构-----
typedef struct StackNode {
    ElemType data;
    struct StackNode *next;
} StackNode, * LinkStack;
```

由于栈的主要操作是在栈顶插入和删除，显然**以链表的头部作为栈顶是最方便的**，而且**没必要像单链表那样为了操作方便附加一个头结点**。
